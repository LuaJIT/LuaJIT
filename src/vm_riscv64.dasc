|// Low-level VM code for RISC-V 64 CPUs.
|// Bytecode interpreter, fast functions and helper functions.
|// Copyright (C) 2022-2026 ISRC, ISCAS. See Copyright Notice in luajit.h
|//
|// Contributed by gns from PLCT Lab, ISRC, ISCAS.
|
|.arch riscv64
|.section code_op, code_sub
|
|.actionlist build_actionlist
|.globals GLOB_
|.globalnames globnames
|.externnames extnames
|
|// Note: The ragged indentation of the instructions is intentional.
|//       The starting columns indicate data dependencies.
|
|//-----------------------------------------------------------------------
|
|// Fixed register assignments for the interpreter.
|// Don't use: x0 = 0, x1 = ra, x2 = sp, x3 = gp, x4 = tp
|
|
|// The following must be C callee-save (but BASE is often refetched).
|.define BASE,		x18	// Base of current Lua stack frame.
|.define KBASE,		x19	// Constants of current Lua function.
|.define PC,		x20	// Next PC.
|.define GLREG,		x21	// Global state.
|.define DISPATCH,	x22	// Opcode dispatch table.
|.define LREG,		x23	// Register holding lua_State (also in SAVE_L).
|.define MULTRES,	x24	// Size of multi-result: (nresults+1)*8.
|
|// Constants for type-comparisons, stores and conversions. C callee-save.
|.define TISNIL,	x8
|.define TISNUM,	x25
|.define TOBIT,		f27	// 2^52 + 2^51.
|
|// The following temporaries are not saved across C calls, except for RA.
|.define RA,		x9	// Callee-save.
|.define RB,		x14
|.define RC,		x15
|.define RD,		x16
|.define INS,		x17
|
|.define TMP0,		x6
|.define TMP1,		x7
|.define TMP2,		x28
|.define TMP3,		x29
|.define TMP4,		x30
|
|// RISC-V lp64d calling convention.
|.define CFUNCADDR,	x5
|.define CARG1,		x10
|.define CARG2,		x11
|.define CARG3,		x12
|.define CARG4,		x13
|.define CARG5,		x14
|.define CARG6,		x15
|.define CARG7,		x16
|.define CARG8,		x17
|
|.define CRET1,		x10
|.define CRET2,		x11
|
|.define FARG1,		f10
|.define FARG2,		f11
|.define FARG3,		f12
|.define FARG4,		f13
|.define FARG5,		f14
|.define FARG6,		f15
|.define FARG7,		f16
|.define FARG8,		f17
|
|.define FRET1,		f10
|.define FRET2,		f11
|
|.define FTMP0,		f0
|.define FTMP1,		f1
|.define FTMP2,		f2
|.define FTMP3,		f3
|.define FTMP4,		f4
|
|// Stack layout while in interpreter. Must match with lj_frame.h.
|// RISC-V 64 lp64d.
|
|.define CFRAME_SPACE,	256	// Delta for sp.
|
|//----- 16 byte aligned, <-- sp entering interpreter
|.define SAVE_ERRF,	252	// 32 bit values.
|.define SAVE_NRES,	248
|.define SAVE_CFRAME,	240	// 64 bit values.
|.define SAVE_L,	232
|.define SAVE_PC,	224
|//----- 16 byte aligned
|// Padding		216
|.define SAVE_GPR_,	112	// .. 112+13*8: 64 bit GPR saves.
|.define SAVE_FPR_,	16	// .. 16+12*8: 64 bit FPR saves.
|
|
|.define TMPD,		0
|//----- 16 byte aligned
|
|.define TMPD_OFS,	0
|
|//-----------------------------------------------------------------------
|
|.macro saveregs
|  addi sp, sp, -CFRAME_SPACE
|  fsd f27, SAVE_FPR_+11*8(sp)
|  fsd f26, SAVE_FPR_+10*8(sp)
|  fsd f25, SAVE_FPR_+9*8(sp)
|  fsd f24, SAVE_FPR_+8*8(sp)
|  fsd f23, SAVE_FPR_+7*8(sp)
|  fsd f22, SAVE_FPR_+6*8(sp)
|  fsd f21, SAVE_FPR_+5*8(sp)
|  fsd f20, SAVE_FPR_+4*8(sp)
|  fsd f19, SAVE_FPR_+3*8(sp)
|  fsd f18, SAVE_FPR_+2*8(sp)
|  fsd f9,  SAVE_FPR_+1*8(sp)
|  fsd f8,  SAVE_FPR_+0*8(sp)
|  sd ra,  SAVE_GPR_+12*8(sp)
|  sd x27, SAVE_GPR_+11*8(sp)
|  sd x26, SAVE_GPR_+10*8(sp)
|  sd x25, SAVE_GPR_+9*8(sp)
|  sd x24, SAVE_GPR_+8*8(sp)
|  sd x23, SAVE_GPR_+7*8(sp)
|  sd x22, SAVE_GPR_+6*8(sp)
|  sd x21, SAVE_GPR_+5*8(sp)
|  sd x20, SAVE_GPR_+4*8(sp)
|  sd x19, SAVE_GPR_+3*8(sp)
|  sd x18, SAVE_GPR_+2*8(sp)
|  sd x9,  SAVE_GPR_+1*8(sp)
|  sd x8,  SAVE_GPR_+0*8(sp)
|.endmacro
|
|.macro restoreregs_ret
|  ld ra,  SAVE_GPR_+12*8(sp)
|  ld x27, SAVE_GPR_+11*8(sp)
|  ld x26, SAVE_GPR_+10*8(sp)
|  ld x25, SAVE_GPR_+9*8(sp)
|  ld x24, SAVE_GPR_+8*8(sp)
|  ld x23, SAVE_GPR_+7*8(sp)
|  ld x22, SAVE_GPR_+6*8(sp)
|  ld x21, SAVE_GPR_+5*8(sp)
|  ld x20, SAVE_GPR_+4*8(sp)
|  ld x19, SAVE_GPR_+3*8(sp)
|  ld x18, SAVE_GPR_+2*8(sp)
|  ld x9,  SAVE_GPR_+1*8(sp)
|  ld x8,  SAVE_GPR_+0*8(sp)
|  fld f27, SAVE_FPR_+11*8(sp)
|  fld f26, SAVE_FPR_+10*8(sp)
|  fld f25, SAVE_FPR_+9*8(sp)
|  fld f24, SAVE_FPR_+8*8(sp)
|  fld f23, SAVE_FPR_+7*8(sp)
|  fld f22, SAVE_FPR_+6*8(sp)
|  fld f21, SAVE_FPR_+5*8(sp)
|  fld f20, SAVE_FPR_+4*8(sp)
|  fld f19, SAVE_FPR_+3*8(sp)
|  fld f18, SAVE_FPR_+2*8(sp)
|  fld f9,  SAVE_FPR_+1*8(sp)
|  fld f8,  SAVE_FPR_+0*8(sp)
|  addi sp, sp, CFRAME_SPACE
|  ret
|.endmacro
|
|//-----------------------------------------------------------------------
|
|// Pseudo-instruction macros
|// Be cautious with local label 9 since we use them here!
|.macro bxeq, a, b, tgt
|  bne a, b, >9
|  j tgt
|9:
|.endmacro
|
|.macro bxne, a, b, tgt
|  beq a, b, >9
|  j tgt
|9:
|.endmacro
|
|.macro bxlt, a, b, tgt
|  bge a, b, >9
|  j tgt
|9:
|.endmacro
|
|.macro bxge, a, b, tgt
|  blt a, b, >9
|  j tgt
|9:
|.endmacro
|
|.macro bxgt, a, b, tgt
|  bge b, a, >9
|  j tgt
|9:
|.endmacro
|
|.macro bxle, a, b, tgt
|  blt b, a, >9
|  j tgt
|9:
|.endmacro
|
|.macro bxltu, a, b, tgt
|  bgeu a, b, >9
|  j tgt
|9:
|.endmacro
|
|.macro bxgeu, a, b, tgt
|  bltu a, b, >9
|  j tgt
|9:
|.endmacro
|
|.macro bxgtu, a, b, tgt
|  bgeu b, a, >9
|  j tgt
|9:
|.endmacro
|
|.macro bxleu, a, b, tgt
|  bltu b, a, >9
|  j tgt
|9:
|.endmacro
|
|.macro bxeqz, a, tgt
|  bxeq a, x0, tgt
|.endmacro
|
|.macro bxnez, a, tgt
|  bxne a, x0, tgt
|.endmacro
|
|.macro bxlez, a, tgt
|  bxge x0, a, tgt
|.endmacro
|
|.macro bxgez, a, tgt
|  bxge a, x0, tgt
|.endmacro
|
|.macro bxltz, a, tgt
|  bxlt a, x0, tgt
|.endmacro
|
|.macro bxgtz, a, tgt
|  bxlt x0, a, tgt
|.endmacro
|
|.macro lxi, a, b
|  lui a, (b)&0xfffff
|  srai a, a, 12
|.endmacro
|
|.macro lzi, a, b
|  lui a, (b)&0xfffff
|  srli a, a, 12
|.endmacro
|
|.macro addxi, a, b, c
|  lui x31, (c)&0xfffff
|  srai x31, x31, 12
|  add a, x31, b
|.endmacro
|
|.macro sext.b, a, b
|  slli a, b, 56
|  srai a, a, 56
|.endmacro
|
|.macro sext.h, a, b
|  slli a, b, 48
|  srai a, a, 48
|.endmacro
|
|.macro zext.h, a, b
|  slli a, b, 48
|  srli a, a, 48
|.endmacro
|
|.macro zext.w, a, b
|  slli a, b, 32
|  srli a, a, 32
|.endmacro
|
|.macro bfextri, a, b, c, d
|  slli a, b, (63-c)
|  srli a, a, (d+63-c)
|.endmacro
|
|//-----------------------------------------------------------------------
|
|// Type definitions. Some of these are only used for documentation.
|.type L,		lua_State,	LREG
|.type GL,		global_State,	GLREG
|.type TVALUE,		TValue
|.type GCOBJ,		GCobj
|.type STR,		GCstr
|.type TAB,		GCtab
|.type LFUNC,		GCfuncL
|.type CFUNC,		GCfuncC
|.type PROTO,		GCproto
|.type UPVAL,		GCupval
|.type NODE,		Node
|.type NARGS8,		int
|.type TRACE,		GCtrace
|.type SBUF,		SBuf
|
|//-----------------------------------------------------------------------
|
|// Trap for not-yet-implemented parts.
|.macro NYI; .long 0x00100073; .endmacro
|
|//-----------------------------------------------------------------------
|
|// Access to frame relative to BASE.
|.define FRAME_PC,	-8
|.define FRAME_FUNC,	-16
|
|//-----------------------------------------------------------------------
|
|// Endian-specific defines. RISC-V only has little endian ABI for now.
|.define OFS_RD,	2
|.define OFS_RA,	1
|.define OFS_OP,	0
|
|// Instruction decode.
|.macro decode_OP1, dst, ins; andi dst, ins, 0xff; .endmacro
|.macro decode_BC4b, dst; slliw dst, dst, 2; .endmacro
|.macro decode_BC8b, dst; slliw dst, dst, 3; .endmacro
|.macro decode_RX8b, dst; andi dst, dst, 0x7f8; .endmacro
|
|.macro decode_OP8a, dst, ins; decode_OP1 dst, ins; .endmacro
|.macro decode_OP8b, dst; decode_BC8b dst; .endmacro
|.macro decode_RA8a, dst, ins; srliw dst, ins, 5; .endmacro
|.macro decode_RA8b, dst; decode_RX8b dst; .endmacro
|.macro decode_RB8a, dst, ins; srliw dst, ins, 21; .endmacro
|.macro decode_RB8b, dst; decode_RX8b dst; .endmacro
|.macro decode_RC8a, dst, ins; srliw dst, ins, 13; .endmacro
|.macro decode_RC8b, dst; decode_RX8b dst; .endmacro
|.macro decode_RD8a, dst, ins; srliw dst, ins, 16; .endmacro
|.macro decode_RD4b, dst; decode_BC4b dst; .endmacro
|.macro decode_RD8b, dst; decode_BC8b dst; .endmacro
|.macro decode_RDtoRC8, dst, src; andi dst, src, 0x7f8; .endmacro
|
|.macro decode_OP8, dst, ins; decode_OP1 dst, ins; decode_BC8b dst; .endmacro
|.macro decode_RA8, dst, ins; decode_RA8a dst, ins; decode_RA8b dst; .endmacro
|.macro decode_RB8, dst, ins; decode_RB8a dst, ins; decode_RB8b dst; .endmacro
|.macro decode_RC8, dst, ins; decode_RC8a dst, ins; decode_RC8b dst; .endmacro
|.macro decode_RD8, dst, ins; decode_RD8a dst, ins; decode_RD8b dst; .endmacro
|
|// Instruction fetch.
|.macro ins_NEXT1
|  lw INS, 0(PC)
|   addi PC, PC, 4
|.endmacro
|// Instruction decode+dispatch.
|.macro ins_NEXT2
|  decode_OP8 TMP1, INS
|  add TMP0, DISPATCH, TMP1
|   decode_RD8a RD, INS
|  ld TMP4, 0(TMP0)
|   decode_RA8a RA, INS
|   decode_RD8b RD
|   decode_RA8b RA
|  jr TMP4
|.endmacro
|.macro ins_NEXT
|  ins_NEXT1
|  ins_NEXT2
|.endmacro
|
|// Instruction footer.
|.if 1
|  // Replicated dispatch. Less unpredictable branches, but higher I-Cache use.
|  .define ins_next, ins_NEXT
|  .define ins_next_, ins_NEXT
|  .define ins_next1, ins_NEXT1
|  .define ins_next2, ins_NEXT2
|.else
|  // Common dispatch. Lower I-Cache use, only one (very) unpredictable branch.
|  // Affects only certain kinds of benchmarks (and only with -j off).
|  .macro ins_next
|    j ->ins_next
|  .endmacro
|  .macro ins_next1
|  .endmacro
|  .macro ins_next2
|    j ->ins_next
|  .endmacro
|  .macro ins_next_
|  ->ins_next:
|    ins_NEXT
|  .endmacro
|.endif
|
|// Call decode and dispatch.
|.macro ins_callt
|  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
|  ld PC, LFUNC:RB->pc
|  lw INS, 0(PC)
|   addi PC, PC, 4
|  decode_OP8 TMP1, INS
|   decode_RA8 RA, INS
|  add TMP0, DISPATCH, TMP1
|  ld TMP0, 0(TMP0)
|   add RA, RA, BASE
|  jr TMP0
|.endmacro
|
|.macro ins_call
|  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, PC = caller PC
|  sd PC, FRAME_PC(BASE)
|  ins_callt
|.endmacro
|
|//-----------------------------------------------------------------------
|
|.macro branch_RD
|  srliw TMP0, RD, 1
|  lui TMP4, (-(BCBIAS_J*4 >> 12)) & 0xfffff
|  addw TMP0, TMP0, TMP4
|  add PC, PC, TMP0
|.endmacro
|
|// Assumes J is relative to GL. Some J members might be out of range though.
#define GL_J(field)	(GG_G2J + (int)offsetof(jit_State, field))
|
#define PC2PROTO(field)  ((int)offsetof(GCproto, field)-(int)sizeof(GCproto))
|
|.macro call_intern, curfunc, func
|->curfunc .. _pcrel_ .. func:
|  auipc CFUNCADDR, extern %pcrel_hi(func)
|  jalr CFUNCADDR, extern %pcrel_lo(lj_ .. curfunc .. _pcrel_ .. func)
|.endmacro
|.macro call_extern, func
|  call extern func
|  empty
|.endmacro
|
|// Set current VM state. Uses TMP0.
|.macro li_vmstate, st; li TMP0, ~LJ_VMST_..st; .endmacro
|.macro st_vmstate; sw TMP0, GL->vmstate; .endmacro
|
|// Move table write barrier back. Overwrites mark and tmp.
|.macro barrierback, tab, mark, tmp, target
|  ld tmp, GL->gc.grayagain
|  andi mark, mark, ~LJ_GC_BLACK & 255		// black2gray(tab)
|  sd tab, GL->gc.grayagain
|  sb mark, tab->marked
|  sd tmp, tab->gclist
|  j target
|.endmacro
|
|// Clear type tag. Isolate lowest 64-17=47 bits of reg.
|.macro cleartp, reg; slli reg, reg, 17; srli reg, reg, 17; .endmacro
|.macro cleartp, dst, reg; slli dst, reg, 17; srli dst, dst, 17; .endmacro
|
|// Set type tag: Merge 17 type bits into bits [47, 63] of dst.
|.macro settp_a, dst; cleartp dst; .endmacro
|.macro settp_a, dst, src; cleartp dst, src; .endmacro
|.macro settp_b, dst, tp;
|  slli x31, tp, 47
|  or dst, dst, x31
|.endmacro
|.macro settp_b, dst, src, tp;
|  slli x31, tp, 47
|  or dst, src, x31
|.endmacro
|.macro settp, dst, tp; settp_a dst; settp_b dst, tp; .endmacro
|.macro settp, dst, src, tp; settp_a dst, src; settp_b dst, dst, tp; .endmacro
|
|// Extract (negative) type tag.
|.macro gettp, dst, src; srai dst, src, 47; .endmacro
|
|// Macros to check the TValue type and extract the GCobj. Branch on failure.
|.macro checktp, reg, tp, target
|  gettp TMP4, reg
|  addi TMP4, TMP4, tp
|  cleartp reg
|  bxnez TMP4, target
|.endmacro
|.macro checktp, dst, reg, tp, target
|  gettp TMP4, reg
|  addi TMP4, TMP4, tp
|  cleartp dst, reg
|  bxnez TMP4, target
|.endmacro
|.macro checkstr, reg, target; checktp reg, -LJ_TSTR, target; .endmacro
|.macro checktab, reg, target; checktp reg, -LJ_TTAB, target; .endmacro
|.macro checkfunc, reg, target; checktp reg, -LJ_TFUNC, target; .endmacro
|.macro checkint, reg, target
|  gettp TMP4, reg
|  bxne TMP4, TISNUM, target
|.endmacro
|.macro checknum, reg, target
|  gettp TMP4, reg
|  sltiu TMP4, TMP4, LJ_TISNUM
|  bxeqz TMP4, target
|.endmacro
|
|.macro mov_false, reg
|  li reg, 0x001
|  slli reg, reg, 47
|  not reg, reg
|.endmacro
|.macro mov_true, reg
|  li reg, 0x001
|  slli reg, reg, 48
|  not reg, reg
|.endmacro
|
|//-----------------------------------------------------------------------
