|// Low-level VM code for ARM CPUs.
|// Bytecode interpreter, fast functions and helper functions.
|// Copyright (C) 2005-2011 Mike Pall. See Copyright Notice in luajit.h
|
|.arch arm
|.section code_op, code_sub
|
|.actionlist build_actionlist
|.globals GLOB_
|.globalnames globnames
|.externnames extnames
|
|// Note: The ragged indentation of the instructions is intentional.
|//       The starting columns indicate data dependencies.
|
|//-----------------------------------------------------------------------
|
|// Fixed register assignments for the interpreter.
|
|// The following must be C callee-save (but BASE is often refetched).
|.define BASE,		r4	// Base of current Lua stack frame.
|.define KBASE,		r5	// Constants of current Lua function.
|.define PC,		r6	// Next PC.
|.define DISPATCH,	r7	// Opcode dispatch table.
|.define LREG,		r8	// Register holding lua_State (also in SAVE_L).
|.define MASKR8,	r9	// 255*8 constant for fast bytecode decoding.
|
|// The following temporaries are not saved across C calls, except for RA/RC.
|.define RA,		r10	// Callee-save.
|.define RC,		r11	// Callee-save.
|.define RB,		r12
|.define OP,		r12	// Overlaps RB, must not be lr.
|.define INS,		lr
|
|// Calling conventions. Also used as temporaries.
|.define CARG1,		r0
|.define CARG2,		r1
|.define CARG3,		r2
|.define CARG4,		r3
|.define CARG12,	r0	// For 1st soft-fp double.
|.define CARG34,	r2	// For 2nd soft-fp double.
|
|.define CRET1,		r0
|.define CRET2,		r1
|
|// Stack layout while in interpreter. Must match with lj_frame.h.
|.define CFRAME_SPACE,	#28
|.define SAVE_ERRF,	[sp, #24]
|.define SAVE_NRES,	[sp, #20]
|.define SAVE_CFRAME,	[sp, #16]
|.define SAVE_L,	[sp, #12]
|.define SAVE_PC,	[sp, #8]
|.define SAVE_MULTRES,	[sp, #4]
|.define ARG5,		[sp]
|
|.define TMPDhi,	[sp, #4]
|.define TMPDlo,	[sp]
|.define TMPD,		[sp]
|.define TMPDp,		sp
|
|.macro saveregs
|  push {r4, r5, r6, r7, r8, r9, r10, r11, lr}
|  sub sp, sp, CFRAME_SPACE
|.endmacro
|.macro restoreregs_ret
|  add sp, sp, CFRAME_SPACE
|  pop {r4, r5, r6, r7, r8, r9, r10, r11, pc}
|.endmacro
|
|// Type definitions. Some of these are only used for documentation.
|.type L,		lua_State,	LREG
|.type GL,		global_State
|.type TVALUE,		TValue
|.type GCOBJ,		GCobj
|.type STR,		GCstr
|.type TAB,		GCtab
|.type LFUNC,		GCfuncL
|.type CFUNC,		GCfuncC
|.type PROTO,		GCproto
|.type UPVAL,		GCupval
|.type NODE,		Node
|.type NARGS8,		int
|.type TRACE,		GCtrace
|
|//-----------------------------------------------------------------------
|
|// Trap for not-yet-implemented parts.
|.macro NYI; ud; .endmacro
|
|//-----------------------------------------------------------------------
|
|// Access to frame relative to BASE.
|.define FRAME_FUNC,	#-8
|.define FRAME_PC,	#-4
|
|.macro decode_RA8, dst, ins; and dst, MASKR8, ins, lsr #5; .endmacro
|.macro decode_RB8, dst, ins; and dst, MASKR8, ins, lsr #21; .endmacro
|.macro decode_RC8, dst, ins; and dst, MASKR8, ins, lsr #13; .endmacro
|.macro decode_RD, dst, ins; lsr dst, ins, #16; .endmacro
|.macro decode_OP, dst, ins; and dst, ins, #255; .endmacro
|
|// Instruction fetch.
|.macro ins_NEXT1
|  ldrb OP, [PC]
|.endmacro
|.macro ins_NEXT2
|   ldr INS, [PC], #4
|.endmacro
|// Instruction decode+dispatch.
|.macro ins_NEXT3
|  ldr OP, [DISPATCH, OP, lsl #2]
|   decode_RA8 RA, INS
|   decode_RD RC, INS
|  bx OP
|.endmacro
|.macro ins_NEXT
|  ins_NEXT1
|  ins_NEXT2
|  ins_NEXT3
|.endmacro
|
|// Instruction footer.
|.if 1
|  // Replicated dispatch. Less unpredictable branches, but higher I-Cache use.
|  .define ins_next, ins_NEXT
|  .define ins_next_, ins_NEXT
|  .define ins_next1, ins_NEXT1
|  .define ins_next2, ins_NEXT2
|  .define ins_next3, ins_NEXT3
|.else
|  // Common dispatch. Lower I-Cache use, only one (very) unpredictable branch.
|  // Affects only certain kinds of benchmarks (and only with -j off).
|  .macro ins_next
|    b ->ins_next
|  .endmacro
|  .macro ins_next1
|  .endmacro
|  .macro ins_next2
|  .endmacro
|  .macro ins_next3
|    b ->ins_next
|  .endmacro
|  .macro ins_next_
|  ->ins_next:
|    ins_NEXT
|  .endmacro
|.endif
|
|// Avoid register name substitution for field name.
#define field_pc	pc
|
|// Call decode and dispatch.
|.macro ins_callt
|  // BASE = new base, CARG3 = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
|  ldr PC, LFUNC:CARG3->field_pc
|  ldrb OP, [PC]  // STALL: load PC. early PC.
|   ldr INS, [PC], #4
|  ldr OP, [DISPATCH, OP, lsl #2]  // STALL: load OP. early OP.
|   decode_RA8 RA, INS
|   add RA, RA, BASE
|  bx OP
|.endmacro
|
|.macro ins_call
|  // BASE = new base, CARG3 = LFUNC/CFUNC, RC = nargs*8, PC = caller PC
|  str PC, [BASE, FRAME_PC]
|  ins_callt  // STALL: locked PC.
|.endmacro
|
|//-----------------------------------------------------------------------
|
|// Macros to test operand types.
|.macro checktp, reg, tp; cmn reg, #-tp; .endmacro
|.macro checktpeq, reg, tp; cmneq reg, #-tp; .endmacro
|.macro checkstr, reg, target; checktp reg, LJ_TSTR; bne target; .endmacro
|.macro checktab, reg, target; checktp reg, LJ_TTAB; bne target; .endmacro
|.macro checkfunc, reg, target; checktp reg, LJ_TFUNC; bne target; .endmacro
|
|// Assumes DISPATCH is relative to GL.
#define DISPATCH_GL(field)	(GG_DISP2G + (int)offsetof(global_State, field))
#define DISPATCH_J(field)	(GG_DISP2J + (int)offsetof(jit_State, field))
|
#define PC2PROTO(field)  ((int)offsetof(GCproto, field)-(int)sizeof(GCproto))
|
|.macro hotloop
|  NYI
|.endmacro
|
|.macro hotcall
|  NYI
|.endmacro
|
|// Set current VM state.
|.macro mv_vmstate, reg, st; mvn reg, #LJ_VMST_..st; .endmacro
|.macro st_vmstate, reg; str reg, [DISPATCH, #DISPATCH_GL(vmstate)]; .endmacro
|
|// Move table write barrier back. Overwrites mark and tmp.
|.macro barrierback, tab, mark, tmp
|  ldr tmp, [DISPATCH, #DISPATCH_GL(gc.grayagain)]
|   bic mark, mark, #LJ_GC_BLACK		// black2gray(tab)
|  str tab, [DISPATCH, #DISPATCH_GL(gc.grayagain)]
|   strb mark, tab->marked
|  str tmp, tab->gclist
|.endmacro
|
|//-----------------------------------------------------------------------

#if !LJ_DUALNUM
#error "Only dual-number mode supported for ARM target"
#endif

/* Generate subroutines used by opcodes and other parts of the VM. */
/* The .code_sub section should be last to help static branch prediction. */
static void build_subroutines(BuildCtx *ctx)
{
  |.code_sub
  |
  |//-----------------------------------------------------------------------
  |//-- Return handling ----------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_returnp:
  |  // See vm_return. Also: RB = previous base.
  |  tst PC, #FRAME_P
  |  beq ->cont_dispatch
  |
  |  // Return from pcall or xpcall fast func.
  |  ldr PC, [RB, FRAME_PC]		// Fetch PC of previous frame.
  |   mvn CARG2, #~LJ_TTRUE
  |  mov BASE, RB
  |  // Prepending may overwrite the pcall frame, so do it at the end.
  |   str CARG2, [RA, FRAME_PC]		// Prepend true to results.
  |  sub RA, RA, #8
  |
  |->vm_returnc:
  |  add RC, RC, #8			// RC = (nresults+1)*8.
  |   ands CARG1, PC, #FRAME_TYPE
  |  str RC, SAVE_MULTRES
  |   beq ->BC_RET_Z			// Handle regular return to Lua.
  |
  |->vm_return:
  |  // BASE = base, RA = resultptr, RC/MULTRES = (nresults+1)*8, PC = return
  |  // CARG1 = PC & FRAME_TYPE
  |  bic RB, PC, #FRAME_TYPEP
  |   cmp CARG1, #FRAME_C
  |  sub RB, BASE, RB			// RB = previous base.
  |   bne ->vm_returnp
  |
  |  str RB, L->base
  |   ldr KBASE, SAVE_NRES
  |    mv_vmstate CARG4, C
  |   sub BASE, BASE, #8
  |  subs CARG3, RC, #8
  |   lsl KBASE, KBASE, #3		// KBASE = (nresults_wanted+1)*8
  |    st_vmstate CARG4
  |  beq >2
  |1:
  |  subs CARG3, CARG3, #8
  |   ldrd CARG12, [RA], #8
  |   strd CARG12, [BASE], #8
  |  bne <1
  |2:
  |  cmp KBASE, RC			// More/less results wanted?
  |  bne >6
  |3:
  |  str BASE, L->top			// Store new top.
  |
  |->vm_leave_cp:
  |  ldr RC, SAVE_CFRAME		// Restore previous C frame.
  |   mov CRET1, #0			// Ok return status for vm_pcall.
  |  str RC, L->cframe
  |
  |->vm_leave_unw:
  |  restoreregs_ret
  |
  |6:
  |  blt >7				// Less results wanted?
  |  // More results wanted. Check stack size and fill up results with nil.
  |  ldr CARG3, L->maxstack
  |   mvn CARG2, #~LJ_TNIL
  |  cmp BASE, CARG3
  |  bhs >8
  |   str CARG2, [BASE, #4]
  |  add RC, RC, #8
  |  add BASE, BASE, #8
  |  b <2
  |
  |7:  // Less results wanted.
  |  sub CARG1, RC, KBASE
  |  cmp KBASE, #0			// LUA_MULTRET+1 case?
  |  subne BASE, BASE, CARG1		// Either keep top or shrink it.
  |  b <3
  |
  |8:  // Corner case: need to grow stack for filling up results.
  |  // This can happen if:
  |  // - A C function grows the stack (a lot).
  |  // - The GC shrinks the stack in between.
  |  // - A return back from a lua_call() with (high) nresults adjustment.
  |  str BASE, L->top			// Save current top held in BASE (yes).
  |  mov CARG2, KBASE
  |  mov CARG1, L
  |  bl extern lj_state_growstack	// (lua_State *L, int n)
  |  ldr BASE, L->top			// Need the (realloced) L->top in BASE.
  |  b <2
  |
  |->vm_unwind_c:			// Unwind C stack, return from vm_pcall.
  |  // (void *cframe, int errcode)
  |  mov sp, CARG1
  |  mov CRET1, CARG2
  |->vm_unwind_c_eh:			// Landing pad for external unwinder.
  |  ldr L, SAVE_L
  |   mv_vmstate CARG4, C
  |  ldr GL:CARG3, L->glref
  |   str CARG4, GL:CARG3->vmstate
  |  b ->vm_leave_unw
  |
  |->vm_unwind_ff:			// Unwind C stack, return from ff pcall.
  |  // (void *cframe)
  |  bic sp, CARG1, #~CFRAME_RAWMASK
  |->vm_unwind_ff_eh:			// Landing pad for external unwinder.
  |  ldr L, SAVE_L
  |   mov MASKR8, #255
  |    mov RC, #16			// 2 results: false + error message.
  |   lsl MASKR8, MASKR8, #3		// MASKR8 = 255*8.
  |  ldr BASE, L->base
  |   ldr DISPATCH, L->glref		// Setup pointer to dispatch table.
  |    mvn CARG1, #~LJ_TFALSE
  |  sub RA, BASE, #8			// Results start at BASE-8.
  |  ldr PC, [BASE, FRAME_PC]		// Fetch PC of previous frame.
  |   add DISPATCH, DISPATCH, #GG_G2DISP
  |   mv_vmstate CARG2, INTERP
  |    str CARG1, [BASE, #-4]		// Prepend false to error message.
  |   st_vmstate CARG2
  |  b ->vm_returnc
  |
  |//-----------------------------------------------------------------------
  |//-- Grow stack for calls -----------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_growstack_c:			// Grow stack for C function.
  |  // CARG1 = L
  |  mov CARG2, #LUA_MINSTACK
  |  b >2
  |
  |->vm_growstack_l:			// Grow stack for Lua function.
  |  // BASE = new base, RA = BASE+framesize*8, RC = nargs*8, PC = first PC
  |  add RC, BASE, RC
  |   sub RA, RA, BASE
  |    mov CARG1, L
  |  str BASE, L->base
  |   add PC, PC, #4			// Must point after first instruction.
  |  str RC, L->top
  |   lsr CARG3, RA, #3
  |2:
  |  // L->base = new base, L->top = top
  |  str PC, SAVE_PC
  |  bl extern lj_state_growstack	// (lua_State *L, int n)
  |  ldr BASE, L->base
  |   ldr RC, L->top
  |  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]
  |   sub NARGS8:RC, RC, BASE
  |  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
  |  ins_callt				// Just retry the call.
  |
  |//-----------------------------------------------------------------------
  |//-- Entry points into the assembler VM ---------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_resume:				// Setup C frame and resume thread.
  |  NYI
  |
  |->vm_pcall:				// Setup protected C frame and enter VM.
  |  // (lua_State *L, TValue *base, int nres1, ptrdiff_t ef)
  |  saveregs
  |  mov PC, #FRAME_CP
  |  str CARG4, SAVE_ERRF
  |  b >1
  |
  |->vm_call:				// Setup C frame and enter VM.
  |  // (lua_State *L, TValue *base, int nres1)
  |  saveregs
  |  mov PC, #FRAME_C
  |
  |1:  // Entry point for vm_pcall above (PC = ftype).
  |  ldr RC, L:CARG1->cframe
  |   str CARG3, SAVE_NRES
  |    mov L, CARG1
  |   str CARG1, SAVE_L
  |    mov BASE, CARG2
  |  str sp, L->cframe			// Add our C frame to cframe chain.
  |    ldr DISPATCH, L->glref		// Setup pointer to dispatch table.
  |   str CARG1, SAVE_PC		// Any value outside of bytecode is ok.
  |  str RC, SAVE_CFRAME
  |    add DISPATCH, DISPATCH, #GG_G2DISP
  |
  |3:  // Entry point for vm_cpcall/vm_resume (BASE = base, PC = ftype).
  |  ldr RB, L->base			// RB = old base (for vmeta_call).
  |   ldr CARG1, L->top
  |    mov MASKR8, #255
  |  add PC, PC, BASE
  |    lsl MASKR8, MASKR8, #3		// MASKR8 = 255*8.
  |  sub PC, PC, RB			// PC = frame delta + frame type
  |    mv_vmstate CARG2, INTERP
  |   sub NARGS8:RC, CARG1, BASE
  |    st_vmstate CARG2
  |
  |->vm_call_dispatch:
  |  // RB = old base, BASE = new base, RC = nargs*8, PC = caller PC
  |  ldrd CARG34, [BASE, FRAME_FUNC]
  |  checkfunc CARG4, ->vmeta_call
  |
  |->vm_call_dispatch_f:
  |  ins_call
  |  // BASE = new base, RC = nargs*8
  |
  |->vm_cpcall:				// Setup protected C frame, call C.
  |  // (lua_State *L, lua_CFunction func, void *ud, lua_CPFunction cp)
  |  saveregs
  |  mov L, CARG1
  |   ldr RA, L:CARG1->stack
  |  str CARG1, SAVE_L
  |   ldr RB, L->top
  |  str CARG1, SAVE_PC			// Any value outside of bytecode is ok.
  |  ldr RC, L->cframe
  |   sub RA, RA, RB			// Compute -savestack(L, L->top).
  |  str sp, L->cframe			// Add our C frame to cframe chain.
  |  mov RB, #0
  |   str RA, SAVE_NRES			// Neg. delta means cframe w/o frame.
  |  str RB, SAVE_ERRF			// No error function.
  |  str RC, SAVE_CFRAME
  |  blx CARG4			// (lua_State *L, lua_CFunction func, void *ud)
  |   ldr DISPATCH, L->glref		// Setup pointer to dispatch table.
  |  movs BASE, CRET1
  |    mov PC, #FRAME_CP
  |   add DISPATCH, DISPATCH, #GG_G2DISP
  |  bne <3				// Else continue with the call.
  |  b ->vm_leave_cp			// No base? Just remove C frame.
  |
  |//-----------------------------------------------------------------------
  |//-- Metamethod handling ------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |//-- Continuation dispatch ----------------------------------------------
  |
  |->cont_dispatch:
  |  NYI
  |
  |->cont_cat:
  |  NYI
  |
  |//-- Table indexing metamethods -----------------------------------------
  |
  |->vmeta_tgets1:
  |  add CARG2, BASE, RB
  |  b >2
  |
  |->vmeta_tgets:
  |  sub CARG2, DISPATCH, #-DISPATCH_GL(tmptv)
  |   mvn CARG4, #~LJ_TTAB
  |  str TAB:RB, [CARG2]
  |   str CARG4, [CARG2, #4]
  |2:
  |   mvn CARG4, #~LJ_TISNUM
  |  str STR:RC, TMPDlo
  |   str CARG4, TMPDhi
  |  mov CARG3, TMPDp
  |  b >1
  |
  |->vmeta_tgetb:			// RC = index
  |  decode_RB8 RB, INS
  |   str RC, TMPDlo
  |   mvn CARG4, #~LJ_TISNUM
  |  add CARG2, BASE, RB
  |   str CARG4, TMPDhi
  |  mov CARG3, TMPDp
  |  b >1
  |
  |->vmeta_tgetv:
  |  add CARG2, BASE, RB
  |   add CARG3, BASE, RC
  |1:
  |   str BASE, L->base
  |  mov CARG1, L
  |   str PC, SAVE_PC
  |  bl extern lj_meta_tget		// (lua_State *L, TValue *o, TValue *k)
  |  // Returns TValue * (finished) or NULL (metamethod).
  |  cmp CRET1, #0
  |  beq >3
  |  ldrd CARG34, [CRET1]
  |   ins_next1
  |   ins_next2
  |  strd CARG34, [BASE, RA]
  |   ins_next3
  |
  |3:  // Call __index metamethod.
  |  // BASE = base, L->top = new base, stack = cont/func/t/k
  |   rsb CARG1, BASE, #FRAME_CONT
  |  ldr BASE, L->top
  |    mov NARGS8:RC, #16		// 2 args for func(t, k).
  |    str PC, [BASE, #-12]		// [cont|PC]
  |   add PC, CARG1, BASE
  |  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]  // Guaranteed to be a function here.
  |  b ->vm_call_dispatch_f
  |
  |//-----------------------------------------------------------------------
  |
  |->vmeta_tsets1:
  |  add CARG2, BASE, RB
  |  b >2
  |
  |->vmeta_tsets:
  |  sub CARG2, DISPATCH, #-DISPATCH_GL(tmptv)
  |   mvn CARG4, #~LJ_TTAB
  |  str TAB:RB, [CARG2]
  |   str CARG4, [CARG2, #4]
  |2:
  |   mvn CARG4, #~LJ_TISNUM
  |  str STR:RC, TMPDlo
  |   str CARG4, TMPDhi
  |  mov CARG3, TMPDp
  |  b >1
  |
  |->vmeta_tsetb:			// RC = index
  |  decode_RB8 RB, INS
  |   str RC, TMPDlo
  |   mvn CARG4, #~LJ_TISNUM
  |  add CARG2, BASE, RB
  |   str CARG4, TMPDhi
  |  mov CARG3, TMPDp
  |  b >1
  |
  |->vmeta_tsetv:
  |  add CARG2, BASE, RB
  |   add CARG3, BASE, RC
  |1:
  |   str BASE, L->base
  |  mov CARG1, L
  |   str PC, SAVE_PC
  |  bl extern lj_meta_tset		// (lua_State *L, TValue *o, TValue *k)
  |  // Returns TValue * (finished) or NULL (metamethod).
  |  cmp CRET1, #0
  |   ldrd CARG34, [BASE, RA]
  |  beq >3
  |   ins_next1
  |  // NOBARRIER: lj_meta_tset ensures the table is not black.
  |  strd CARG34, [CRET1]
  |   ins_next2
  |   ins_next3
  |
  |3:  // Call __newindex metamethod.
  |  // BASE = base, L->top = new base, stack = cont/func/t/k/(v)
  |   rsb CARG1, BASE, #FRAME_CONT
  |  ldr BASE, L->top
  |    mov NARGS8:RC, #24		// 3 args for func(t, k, v).
  |   strd CARG34, [BASE, #16]		// Copy value to third argument.
  |    str PC, [BASE, #-12]		// [cont|PC]
  |   add PC, CARG1, BASE
  |  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]  // Guaranteed to be a function here.
  |  b ->vm_call_dispatch_f
  |
  |//-- Comparison metamethods ---------------------------------------------
  |
  |->vmeta_comp:
  |  NYI
  |
  |->cont_nop:
  |  ins_next
  |
  |->cont_ra:				// RA = resultptr
  |  NYI
  |
  |->cont_condt:			// RA = resultptr
  |  NYI
  |
  |->cont_condf:			// RA = resultptr
  |  NYI
  |
  |->vmeta_equal:
  |  NYI
  |
  |//-- Arithmetic metamethods ---------------------------------------------
  |
  |->vmeta_arith_vn:
  |  decode_RB8 RB, INS
  |   decode_RC8 RC, INS
  |  add CARG3, BASE, RB
  |   add CARG4, KBASE, RC
  |  b >1
  |
  |->vmeta_arith_nv:
  |  decode_RB8 RB, INS
  |   decode_RC8 RC, INS
  |  add CARG4, BASE, RB
  |   add CARG3, KBASE, RC
  |  b >1
  |
  |->vmeta_unm:
  |  add CARG3, BASE, RC
  |  add CARG4, BASE, RC
  |  b >1
  |
  |->vmeta_arith_vv:
  |  decode_RB8 RB, INS
  |   decode_RC8 RC, INS
  |  add CARG3, BASE, RB
  |   add CARG4, BASE, RC
  |1:
  |  decode_OP OP, INS
  |   add CARG2, BASE, RA
  |    str BASE, L->base
  |   mov CARG1, L
  |    str PC, SAVE_PC
  |  str OP, ARG5
  |  bl extern lj_meta_arith  // (lua_State *L, TValue *ra,*rb,*rc, BCReg op)
  |  // Returns NULL (finished) or TValue * (metamethod).
  |  cmp CRET1, #0
  |  beq ->cont_nop
  |
  |  // Call metamethod for binary op.
  |->vmeta_binop:
  |  // BASE = old base, CRET1 = new base, stack = cont/func/o1/o2
  |  NYI
  |
  |->vmeta_len:
  |  NYI
  |
  |//-- Call metamethod ----------------------------------------------------
  |
  |->vmeta_call:			// Resolve and call __call metamethod.
  |  NYI
  |
  |->vmeta_callt:			// Resolve __call for BC_CALLT.
  |  NYI
  |
  |//-- Argument coercion for 'for' statement ------------------------------
  |
  |->vmeta_for:
  |  mov CARG1, L
  |   str BASE, L->base
  |  mov CARG2, RA
  |   str PC, SAVE_PC
  |  bl extern lj_meta_for	// (lua_State *L, TValue *base)
#if LJ_HASJIT
  |   ldrb OP, [PC, #-4]
#endif
  |  ldr INS, [PC, #-4]
#if LJ_HASJIT
  |   cmp OP, #BC_JFORI
#endif
  |  decode_RA8 RA, INS
  |  decode_RD RC, INS
#if LJ_HASJIT
  |   beq =>BC_JFORI
#endif
  |  b =>BC_FORI
  |
  |//-----------------------------------------------------------------------
  |//-- Fast functions -----------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |.macro .ffunc, name
  |->ff_ .. name:
  |.endmacro
  |
  |.macro .ffunc_1, name
  |->ff_ .. name:
  |  ldrd CARG12, [BASE]
  |   cmp NARGS8:RC, #8
  |   blo ->fff_fallback
  |.endmacro
  |
  |.macro .ffunc_2, name
  |->ff_ .. name:
  |  ldrd CARG12, [BASE]
  |   ldrd CARG34, [BASE, #8]
  |    cmp NARGS8:RC, #16
  |    blo ->fff_fallback
  |.endmacro
  |
  |.macro .ffunc_n, name
  |  .ffunc_1 name
  |  checktp CARG2, LJ_TISNUM
  |  bhs ->fff_fallback
  |.endmacro
  |
  |.macro .ffunc_nn, name
  |  .ffunc_2 name
  |  checktp CARG2, LJ_TISNUM
  |  cmnlo CARG4, #-LJ_TISNUM
  |  bhs ->fff_fallback
  |.endmacro
  |
  |.macro ffgccheck
  |  NYI
  |.endmacro
  |
  |//-- Base library: checks -----------------------------------------------
  |
  |.ffunc_1 assert
  |  checktp CARG2, LJ_TTRUE
  |  bhi ->fff_fallback
  |   ldr PC, [BASE, FRAME_PC]
  |  strd CARG12, [BASE, #-8]
  |  mov RB, BASE
  |  subs RA, NARGS8:RC, #8
  |   add RC, NARGS8:RC, #8		// Compute (nresults+1)*8.
  |  beq ->fff_res			// Done if exactly 1 argument.
  |1:
  |   ldrd CARG12, [RB, #8]
  |  subs RA, RA, #8
  |   strd CARG12, [RB], #8
  |  bne <1
  |  b ->fff_res
  |
  |.ffunc type
  |  ldr CARG2, [BASE, #4]
  |   cmp NARGS8:RC, #8
  |   blo ->fff_fallback
  |  checktp CARG2, LJ_TISNUM
  |  mvnlo CARG2, #~LJ_TISNUM
  |  rsb CARG4, CARG2, #(int)(offsetof(GCfuncC, upvalue)>>3)-1
  |  lsl CARG4, CARG4, #3
  |  ldrd CARG12, [CFUNC:CARG3, CARG4]
  |  b ->fff_restv
  |
  |//-- Base library: getters and setters ---------------------------------
  |
  |.ffunc_1 getmetatable
  |  checktp CARG2, LJ_TTAB
  |  cmnne CARG2, #-LJ_TUDATA
  |  bne >6
  |1:  // Field metatable must be at same offset for GCtab and GCudata!
  |  ldr TAB:RB, TAB:CARG1->metatable
  |2:
  |   mvn CARG2, #~LJ_TNIL
  |   ldr STR:RC, [DISPATCH, #DISPATCH_GL(gcroot[GCROOT_MMNAME+MM_metatable])]
  |  cmp TAB:RB, #0
  |  beq ->fff_restv
  |  ldr CARG3, TAB:RB->hmask
  |   ldr CARG4, STR:RC->hash
  |    ldr NODE:INS, TAB:RB->node
  |  and CARG3, CARG3, CARG4		// idx = str->hash & tab->hmask
  |  add CARG3, CARG3, CARG3, lsl #1
  |    add NODE:INS, NODE:INS, CARG3, lsl #3	// node = tab->node + idx*3*8
  |3:  // Rearranged logic, because we expect _not_ to find the key.
  |  ldrd CARG34, NODE:INS->key  // STALL: early NODE:INS.
  |   ldrd CARG12, NODE:INS->val
  |    ldr NODE:INS, NODE:INS->next
  |  cmp CARG3, STR:RC
  |  checktpeq CARG4, LJ_TSTR
  |  beq >5
  |  cmp NODE:INS, #0
  |  bne <3
  |4:
  |  mov CARG1, RB			// Use metatable as default result.
  |  mvn CARG2, #~LJ_TTAB
  |  b ->fff_restv
  |5:
  |  checktp CARG2, LJ_TNIL
  |  bne ->fff_restv
  |  b <4
  |
  |6:
  |  checktp CARG2, LJ_TISNUM
  |  mvnhs CARG2, CARG2
  |  movlo CARG2, #~LJ_TISNUM
  |  add CARG4, DISPATCH, CARG2, lsl #2
  |  ldr TAB:RB, [CARG4, #DISPATCH_GL(gcroot[GCROOT_BASEMT])]
  |  b <2
  |
  |.ffunc_2 setmetatable
  |  // Fast path: no mt for table yet and not clearing the mt.
  |  checktp CARG2, LJ_TTAB
  |   ldreq TAB:RB, TAB:CARG1->metatable
  |  checktpeq CARG4, LJ_TTAB
  |    ldrbeq CARG4, TAB:CARG1->marked
  |   cmpeq TAB:RB, #0
  |  bne ->fff_fallback
  |    tst CARG4, #LJ_GC_BLACK		// isblack(table)
  |     str TAB:CARG3, TAB:CARG1->metatable
  |    beq ->fff_restv
  |  barrierback TAB:CARG1, CARG4, CARG3
  |  b ->fff_restv
  |
  |.ffunc rawget
  |  NYI
  |
  |//-- Base library: conversions ------------------------------------------
  |
  |.ffunc_1 tonumber
  |  // Only handles the number case inline (without a base argument).
  |  checktp CARG2, LJ_TISNUM
  |  bls ->fff_restv
  |  b ->fff_fallback
  |
  |.ffunc_1 tostring
  |  // Only handles the string or number case inline.
  |  checktp CARG2, LJ_TSTR
  |  // A __tostring method in the string base metatable is ignored.
  |  beq ->fff_restv
  |  // Handle numbers inline, unless a number base metatable is present.
  |  ldr CARG4, [DISPATCH, #DISPATCH_GL(gcroot[GCROOT_BASEMT_NUM])]
  |   mov CARG1, L
  |  checktp CARG2, LJ_TISNUM
  |  cmpls CARG4, #0
  |  bhi ->fff_fallback
  |  str BASE, L->base
  |   mov CARG2, BASE
  |  str PC, SAVE_PC
  |  bl extern lj_str_fromnumber	// (lua_State *L, cTValue *o)
  |  // Returns GCstr *.
  |  ldr BASE, L->base
  |  mvn CARG2, #~LJ_TSTR
  |  b ->fff_restv
  |
  |//-- Base library: iterators -------------------------------------------
  |
  |.ffunc_1 next
  |   mvn CARG4, #~LJ_TNIL
  |  checktab CARG2, ->fff_fallback
  |   strd CARG34, [BASE, NARGS8:RC]	// Set missing 2nd arg to nil.
  |   ldr PC, [BASE, FRAME_PC]
  |  mov CARG2, CARG1
  |    str BASE, L->base		// Add frame since C call can throw.
  |  mov CARG1, L
  |    str BASE, L->top			// Dummy frame length is ok.
  |  add CARG3, BASE, #8
  |   str PC, SAVE_PC
  |  bl extern lj_tab_next	// (lua_State *L, GCtab *t, TValue *key)
  |  // Returns 0 at end of traversal.
  |  cmp CRET1, #0
  |  mvneq CRET2, #~LJ_TNIL
  |  beq ->fff_restv			// End of traversal: return nil.
  |  ldrd CARG12, [BASE, #8]		// Copy key and value to results.
  |   ldrd CARG34, [BASE, #16]
  |    mov RC, #(2+1)*8
  |  strd CARG12, [BASE, #-8]
  |   strd CARG34, [BASE]
  |  b ->fff_res
  |
  |.ffunc_1 pairs
  |  checktab CARG2, ->fff_fallback
#ifdef LUAJIT_ENABLE_LUA52COMPAT
  |  ldr TAB:RB, TAB:CARG1->metatable
#endif
  |   ldrd CFUNC:CARG34, CFUNC:CARG3->upvalue[0]
  |    ldr PC, [BASE, FRAME_PC]
#ifdef LUAJIT_ENABLE_LUA52COMPAT
  |  cmp TAB:RB, #0
  |  bne ->fff_fallback
#endif
  |  mvn CARG2, #~LJ_TNIL
  |    mov RC, #(3+1)*8
  |   strd CFUNC:CARG34, [BASE, #-8]
  |  str CARG2, [BASE, #12]
  |  b ->fff_res
  |
  |.ffunc_2 ipairs_aux
  |  checktp CARG2, LJ_TTAB
  |  checktpeq CARG4, LJ_TISNUM
  |  bne ->fff_fallback
  |  ldr RB, TAB:CARG1->asize
  |   ldr RC, TAB:CARG1->array
  |  add CARG3, CARG3, #1
  |    ldr PC, [BASE, FRAME_PC]
  |  cmp CARG3, RB
  |   add RC, RC, CARG3, lsl #3
  |  strd CARG34, [BASE, #-8]
  |   ldrdlo CARG12, [RC]
  |   mov RC, #(0+1)*8
  |  bhs >2				// Not in array part?
  |1:
  |   checktp CARG2, LJ_TNIL
  |   movne RC, #(2+1)*8
  |   strdne CARG12, [BASE]
  |  b ->fff_res
  |2:  // Check for empty hash part first. Otherwise call C function.
  |  ldr RB, TAB:CARG1->hmask
  |   mov CARG2, CARG3
  |  cmp RB, #0
  |  beq ->fff_res
  |  bl extern lj_tab_getinth		// (GCtab *t, int32_t key)
  |  // Returns cTValue * or NULL.
  |  cmp CRET1, #0
  |  beq ->fff_res
  |  ldrd CARG12, [CRET1]
  |  b <1
  |
  |.ffunc_1 ipairs
  |  checktab CARG2, ->fff_fallback
#ifdef LUAJIT_ENABLE_LUA52COMPAT
  |  ldr TAB:RB, TAB:CARG1->metatable
#endif
  |   ldrd CFUNC:CARG34, CFUNC:CARG3->upvalue[0]
  |    ldr PC, [BASE, FRAME_PC]
#ifdef LUAJIT_ENABLE_LUA52COMPAT
  |  cmp TAB:RB, #0
  |  bne ->fff_fallback
#endif
  |  mov CARG1, #0
  |  mvn CARG2, #~LJ_TISNUM
  |    mov RC, #(3+1)*8
  |   strd CFUNC:CARG34, [BASE, #-8]
  |  strd CARG12, [BASE, #8]
  |  b ->fff_res
  |
  |//-- Base library: catch errors ----------------------------------------
  |
  |.ffunc pcall
  |  ldrb RA, [DISPATCH, #DISPATCH_GL(hookmask)]
  |   cmp NARGS8:RC, #8
  |   blo ->fff_fallback
  |  tst RA, #HOOK_ACTIVE		// Remember active hook before pcall.
  |   mov RB, BASE
  |   add BASE, BASE, #8
  |  moveq PC, #8+FRAME_PCALL
  |  movne PC, #8+FRAME_PCALLH
  |   sub NARGS8:RC, NARGS8:RC, #8
  |  b ->vm_call_dispatch
  |
  |.ffunc_2 xpcall
  |  ldrb RA, [DISPATCH, #DISPATCH_GL(hookmask)]
  |  checkfunc CARG4, ->fff_fallback	// Traceback must be a function.
  |   mov RB, BASE
  |  strd CARG12, [BASE, #8]		// Swap function and traceback.
  |   strd CARG34, [BASE]
  |  tst RA, #HOOK_ACTIVE		// Remember active hook before pcall.
  |   add BASE, BASE, #16
  |  moveq PC, #16+FRAME_PCALL
  |  movne PC, #16+FRAME_PCALLH
  |   sub NARGS8:RC, NARGS8:RC, #16
  |  b ->vm_call_dispatch
  |
  |//-- Coroutine library --------------------------------------------------
  |
  |.macro coroutine_resume_wrap, resume
  |.if resume
  |.ffunc_1 coroutine_resume
  |.else
  |.ffunc coroutine_wrap_aux
  |.endif
  |  NYI
  |.endmacro
  |
  |  coroutine_resume_wrap 1		// coroutine.resume
  |  coroutine_resume_wrap 0		// coroutine.wrap
  |
  |.ffunc coroutine_yield
  |  NYI
  |
  |//-- Math library -------------------------------------------------------
  |
  |.align 8
  |1:
  |  .long 0x00000000, 0x41e00000	// 2^31.
  |
  |.ffunc_1 math_abs
  |  checktp CARG2, LJ_TISNUM
  |  bhi ->fff_fallback
  |  bicne CARG2, CARG2, #0x80000000
  |  bne ->fff_restv
  |  cmp CARG1, #0
  |  rsbslt CARG1, CARG1, #0
  |  ldrdvs CARG12, <1
  |  // Fallthrough.
  |
  |->fff_restv:
  |  // CARG12 = TValue result.
  |  ldr PC, [BASE, FRAME_PC]
  |  strd CARG12, [BASE, #-8]
  |->fff_res1:
  |  // PC = return.
  |  mov RC, #(1+1)*8
  |->fff_res:
  |  // RC = (nresults+1)*8, PC = return.
  |  ands CARG1, PC, #FRAME_TYPE
  |  ldreq INS, [PC, #-4]
  |   str RC, SAVE_MULTRES
  |  sub RA, BASE, #8
  |  bne ->vm_return
  |  decode_RB8 RB, INS
  |5:
  |  cmp RB, RC				// More results expected?
  |  bhi >6
  |  decode_RA8 CARG1, INS
  |   ins_next1
  |   ins_next2
  |  // Adjust BASE. KBASE is assumed to be set for the calling frame.
  |  sub BASE, RA, CARG1
  |   ins_next3
  |
  |6:  // Fill up results with nil.
  |  add CARG2, RA, RC
  |  mvn CARG1, #~LJ_TNIL
  |   add RC, RC, #8
  |  str CARG1, [CARG2, #-4]
  |  b <5
  |
  |.macro math_extern, func
  |  .ffunc_n math_ .. func
  |  bl extern func
  |  b ->fff_restv
  |.endmacro
  |
  |.macro math_extern2, func
  |  .ffunc_nn math_ .. func
  |  bl extern func
  |  b ->fff_restv
  |.endmacro
  |
  |.macro math_round, func
  |  .ffunc math_ .. func
  |  NYI
  |.endmacro
  |
  |  math_round floor
  |  math_round ceil
  |
  |  math_extern sqrt
  |  math_extern log
  |  math_extern log10
  |  math_extern exp
  |  math_extern sin
  |  math_extern cos
  |  math_extern tan
  |  math_extern asin
  |  math_extern acos
  |  math_extern atan
  |  math_extern sinh
  |  math_extern cosh
  |  math_extern tanh
  |  math_extern2 pow
  |  math_extern2 atan2
  |  math_extern2 fmod
  |
  |->ff_math_deg:
  |.ffunc_n math_rad
  |  ldrd CARG34, CFUNC:CARG3->upvalue[0]
  |  bl extern __aeabi_dmul
  |  b ->fff_restv
  |
  |.ffunc_2 math_ldexp
  |  checktp CARG2, LJ_TISNUM
  |  bhs ->fff_fallback
  |  checktp CARG4, LJ_TISNUM
  |  bne ->fff_fallback
  |  bl extern ldexp			// (double x, int exp)
  |  b ->fff_restv
  |
  |.ffunc_n math_frexp
  |  mov CARG3, sp
  |  bl extern frexp
  |   ldr CARG3, [sp]
  |   mvn CARG4, #~LJ_TISNUM
  |    ldr PC, [BASE, FRAME_PC]
  |  strd CARG12, [BASE, #-8]
  |    mov RC, #(2+1)*8
  |   strd CARG34, [BASE]
  |  b ->fff_res
  |
  |.ffunc_n math_modf
  |  sub CARG3, BASE, #8
  |   ldr PC, [BASE, FRAME_PC]
  |  bl extern modf
  |   mov RC, #(2+1)*8
  |  strd CARG12, [BASE]
  |  b ->fff_res
  |
  |.macro math_minmax, name, cond, fcond
  |  .ffunc_1 name
  |  checktp CARG2, LJ_TISNUM
  |   mov RA, #8
  |  bne >4
  |1:  // Handle integers.
  |  ldrd CARG34, [BASE, RA]
  |   cmp RA, RC
  |   bhs ->fff_restv
  |  checktp CARG4, LJ_TISNUM
  |  bne >3
  |  cmp CARG1, CARG3
  |   add RA, RA, #8
  |  mov..cond CARG1, CARG3
  |  b <1
  |3:
  |  bhi ->fff_fallback
  |  // Convert intermediate result to number and continue below.
  |  bl extern __aeabi_i2d
  |  ldrd CARG34, [BASE, RA]
  |  b >6
  |
  |4:
  |  bhi ->fff_fallback
  |5:  // Handle numbers.
  |  ldrd CARG34, [BASE, RA]
  |   cmp RA, RC
  |   bhs ->fff_restv
  |  checktp CARG4, LJ_TISNUM
  |  bhs >7
  |6:
  |  bl extern __aeabi_cdcmple
  |   add RA, RA, #8
  |  mov..fcond CARG1, CARG3
  |  mov..fcond CARG2, CARG4
  |  b <5
  |7:  // Convert integer to number and continue above.
  |  bhi ->fff_fallback
  |  strd CARG12, TMPD
  |  mov CARG1, CARG3
  |  bl extern __aeabi_i2d
  |  ldrd CARG34, TMPD
  |  b <6
  |.endmacro
  |
  |  math_minmax math_min, gt, hi
  |  math_minmax math_max, lt, lo
  |
  |//-- String library -----------------------------------------------------
  |
  |.ffunc_1 string_len
  |  NYI
  |
  |.ffunc string_byte			// Only handle the 1-arg case here.
  |  NYI
  |
  |.ffunc string_char			// Only handle the 1-arg case here.
  |  NYI
  |
  |.ffunc string_sub
  |  NYI
  |
  |.ffunc string_rep			// Only handle the 1-char case inline.
  |  NYI
  |
  |.ffunc string_reverse
  |  NYI
  |
  |.macro ffstring_case, name, lo
  |  .ffunc name
  |  NYI
  |.endmacro
  |
  |ffstring_case string_lower, 65
  |ffstring_case string_upper, 97
  |
  |//-- Table library ------------------------------------------------------
  |
  |.ffunc_1 table_getn
  |  NYI
  |
  |//-- Bit library --------------------------------------------------------
  |
  |.macro .ffunc_bit, name
  |  .ffunc_n bit_..name
  |  NYI
  |.endmacro
  |
  |.ffunc_bit tobit
  |  NYI
  |->fff_resbit:
  |  NYI
  |
  |.macro .ffunc_bit_op, name, ins
  |  .ffunc_bit name
  |  NYI
  |.endmacro
  |
  |.ffunc_bit_op band, and
  |.ffunc_bit_op bor, or
  |.ffunc_bit_op bxor, eor
  |
  |.ffunc_bit bswap
  |  NYI
  |
  |.ffunc_bit bnot
  |  NYI
  |
  |.macro .ffunc_bit_sh, name, ins, shmod
  |  .ffunc_nn bit_..name
  |  NYI
  |.endmacro
  |
  |.ffunc_bit_sh lshift, NYI, 1
  |.ffunc_bit_sh rshift, NYI, 1
  |.ffunc_bit_sh arshift, NYI, 1
  |.ffunc_bit_sh rol, NYI, 2
  |.ffunc_bit_sh ror, NYI, 0
  |
  |//-----------------------------------------------------------------------
  |
  |->fff_fallback:			// Call fast function fallback handler.
  |  // BASE = new base, RC = nargs*8
  |   ldr CARG3, [BASE, FRAME_FUNC]
  |  ldr CARG2, L->maxstack
  |  add CARG1, BASE, NARGS8:RC
  |    ldr PC, [BASE, FRAME_PC]		// Fallback may overwrite PC.
  |  str CARG1, L->top
  |   ldr CARG3, CFUNC:CARG3->f
  |    str BASE, L->base
  |  add CARG1, CARG1, #8*LUA_MINSTACK
  |    str PC, SAVE_PC			// Redundant (but a defined value).
  |  cmp CARG1, CARG2
  |   mov CARG1, L
  |  bhi >5				// Need to grow stack.
  |   blx CARG3				// (lua_State *L)
  |  // Either throws an error, or recovers and returns -1, 0 or nresults+1.
  |  cmp CRET1, #0
  |   lsl RC, CRET1, #3
  |   sub RA, BASE, #8
  |  bgt ->fff_res			// Returned nresults+1?
  |1:  // Returned 0 or -1: retry fast path.
  |   ldr CARG1, L->top
  |    ldr LFUNC:CARG3, [BASE, FRAME_FUNC]
  |   sub NARGS8:RC, CARG1, BASE
  |  bne >2				// Returned -1?
  |  ins_callt				// Returned 0: retry fast path.
  |
  |2:  // Reconstruct previous base for vmeta_call during tailcall.
  |  ands CARG1, PC, #FRAME_TYPE
  |   bic CARG2, PC, #FRAME_TYPEP
  |  ldreq INS, [PC, #-4]
  |  andeq CARG2, MASKR8, INS, lsr #5	// Conditional decode_RA8.
  |  sub RB, BASE, CARG2
  |  b ->vm_call_dispatch		// Resolve again for tailcall.
  |
  |5:  // Grow stack for fallback handler.
  |  mov CARG2, #LUA_MINSTACK
  |  bl extern lj_state_growstack	// (lua_State *L, int n)
  |  ldr BASE, L->base
  |  cmp CARG1, CARG1			// Set zero-flag to force retry.
  |  b <1
  |
  |->fff_gcstep:			// Call GC step function.
  |  NYI
  |
  |//-----------------------------------------------------------------------
  |//-- Special dispatch targets -------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_record:				// Dispatch target for recording phase.
#if LJ_HASJIT
  |  NYI
#endif
  |
  |->vm_rethook:			// Dispatch target for return hooks.
  |  NYI
  |
  |->vm_inshook:			// Dispatch target for instr/line hooks.
  |  NYI
  |
  |->cont_hook:				// Continue from hook yield.
  |  NYI
  |
  |->vm_hotloop:			// Hot loop counter underflow.
#if LJ_HASJIT
  |  NYI
#endif
  |
  |->vm_callhook:			// Dispatch target for call hooks.
  |  NYI
  |
  |->vm_hotcall:			// Hot call counter underflow.
  |  NYI
  |
  |//-----------------------------------------------------------------------
  |//-- Trace exit handler -------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_exit_handler:
#if LJ_HASJIT
  |  NYI
#endif
  |->vm_exit_interp:
#if LJ_HASJIT
  |  NYI
#endif
  |
  |//-----------------------------------------------------------------------
  |//-- Math helper functions ----------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |// FP value rounding. Called by math.floor/math.ceil fast functions
  |// and from JIT code.
  |//
  |.macro vm_round, name, mode
  |->name:
  |  NYI
  |.endmacro
  |
  |  vm_round vm_floor, 0
  |  vm_round vm_ceil,  1
#if LJ_HASJIT
  |  vm_round vm_trunc, 2
#else
  |->vm_trunc:
#endif
  |
  |->vm_mod:
  |  NYI
  |
  |->vm_powi:
#if LJ_HASJIT
  |  NYI
#endif
  |
  |->vm_foldfpm:
#if LJ_HASJIT
  |  NYI
#endif
  |
  |// Callable from C: double lj_vm_foldarith(double x, double y, int op)
  |// Compute x op y for basic arithmetic operators (+ - * / % ^ and unary -)
  |// and basic math functions. ORDER ARITH
  |->vm_foldarith:
  |  ldr OP, [sp]
  |  cmp OP, #1
  |  blo extern __aeabi_dadd
  |  beq extern __aeabi_dsub
  |  cmp OP, #3
  |  blo extern __aeabi_dmul
  |  beq extern __aeabi_ddiv
  |  cmp OP, #5
  |  blo ->vm_mod
  |  beq extern pow
  |  cmp OP, #7
  |  eorlo CARG2, CARG2, #0x80000000
  |  biceq CARG2, CARG2, #0x80000000
  |  bxls lr
  |  NYI  // Other operations only needed by JIT compiler.
  |
  |//-----------------------------------------------------------------------
  |//-- Miscellaneous functions --------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |//-----------------------------------------------------------------------
  |//-- FFI helper functions -----------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_ffi_call:
#if LJ_HASFFI
  |  NYI
#endif
  |
  |//-----------------------------------------------------------------------
}

/* Generate the code for a single instruction. */
static void build_ins(BuildCtx *ctx, BCOp op, int defop)
{
  int vk = 0;
  |=>defop:

  switch (op) {

  /* -- Comparison ops ---------------------------------------------------- */

  /* Remember: all ops branch for a true comparison, fall through otherwise. */

  case BC_ISLT: case BC_ISGE: case BC_ISLE: case BC_ISGT:
    |  NYI
    break;

  case BC_ISEQV: case BC_ISNEV:
    vk = op == BC_ISEQV;
    |  NYI
    break;

  case BC_ISEQS: case BC_ISNES:
    vk = op == BC_ISEQS;
    |  NYI
    break;

  case BC_ISEQN: case BC_ISNEN:
    vk = op == BC_ISEQN;
    |  NYI
    break;

  case BC_ISEQP: case BC_ISNEP:
    vk = op == BC_ISEQP;
    |  NYI
    break;

  /* -- Unary test and copy ops ------------------------------------------- */

  case BC_ISTC: case BC_ISFC: case BC_IST: case BC_ISF:
    |  NYI
    break;

  /* -- Unary ops --------------------------------------------------------- */

  case BC_MOV:
    |  // RA = dst*8, RC = src
    |  lsl RC, RC, #3
    |   ins_next1
    |  ldrd CARG12, [BASE, RC]
    |   ins_next2
    |  strd CARG12, [BASE, RA]
    |   ins_next3
    break;
  case BC_NOT:
    |  // RA = dst*8, RC = src
    |  add RC, BASE, RC, lsl #3
    |   ins_next1
    |  ldr CARG1, [RC, #4]
    |   add RA, BASE, RA
    |   ins_next2
    |  checktp CARG1, LJ_TTRUE
    |  mvnls CARG2, #~LJ_TFALSE
    |  mvnhi CARG2, #~LJ_TTRUE
    |  str CARG2, [RA, #4]
    |   ins_next3
    break;
  case BC_UNM:
    |  // RA = dst*8, RC = src
    |  lsl RC, RC, #3
    |  ldrd CARG12, [BASE, RC]
    |   ins_next1
    |   ins_next2
    |  checktp CARG2, LJ_TISNUM
    |  bne >5
    |  rsbs CARG1, CARG1, #0
    |  bvs >4
    |9:
    |  strd CARG12, [BASE, RA]
    |   ins_next3
    |4:
    |  mov CARG2, #0x01e00000  // 2^31.
    |  mov CARG1, #0
    |  orr CARG2, CARG2, #0x40000000
    |  b <9
    |5:
    |  bhi ->vmeta_unm
    |  add CARG2, CARG2, #0x80000000
    |  b <9
    break;
  case BC_LEN:
    |  // RA = dst*8, RC = src
    |  lsl RC, RC, #3
    |  ldrd CARG12, [BASE, RC]
    |  checkstr CARG2, >2
    |  ldr CARG1, STR:CARG1->len
    |1:
    |  mvn CARG2, #~LJ_TISNUM
    |   ins_next1
    |   ins_next2
    |  strd CARG12, [BASE, RA]
    |   ins_next3
    |2:
    |  checktab CARG2, ->vmeta_len
    |  bl extern lj_tab_len		// (GCtab *t)
    |  // Returns uint32_t (but less than 2^31).
    |  b <1
    break;

  /* -- Binary ops -------------------------------------------------------- */

    |.macro ins_arithcheck, cond, ncond, target
    ||if (vk == 1) {
    |   cmn CARG4, #-LJ_TISNUM
    |    cmn..cond CARG2, #-LJ_TISNUM
    ||} else {
    |   cmn CARG2, #-LJ_TISNUM
    |    cmn..cond CARG4, #-LJ_TISNUM
    ||}
    |  b..ncond target
    |.endmacro
    |.macro ins_arithcheck_int, target
    |  ins_arithcheck eq, ne, target
    |.endmacro
    |.macro ins_arithcheck_num, target
    |  ins_arithcheck lo, hs, target
    |.endmacro
    |
    |.macro ins_arithpre
    |  decode_RB8 RB, INS
    |   decode_RC8 RC, INS
    |  // RA = dst*8, RB = src1*8, RC = src2*8 | num_const*8
    ||vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    ||switch (vk) {
    ||case 0:
    |   ldrd CARG12, [BASE, RB]
    |    ldrd CARG34, [KBASE, RC]
    ||  break;
    ||case 1:
    |   ldrd CARG34, [BASE, RB]
    |    ldrd CARG12, [KBASE, RC]
    ||  break;
    ||default:
    |   ldrd CARG12, [BASE, RB]
    |    ldrd CARG34, [BASE, RC]
    ||  break;
    ||}
    |.endmacro
    |
    |.macro ins_arithfallback, ins
    ||switch (vk) {
    ||case 0:
    |   ins ->vmeta_arith_vn
    ||  break;
    ||case 1:
    |   ins ->vmeta_arith_nv
    ||  break;
    ||default:
    |   ins ->vmeta_arith_vv
    ||  break;
    ||}
    |.endmacro
    |
    |.macro ins_arithdn, intins, fpcall
    |  ins_arithpre
    |   ins_next1
    |  ins_arithcheck_int >5
    |.if "intins" == "smull"
    |  smull CARG1, RC, CARG3, CARG1
    |  cmp RC, CARG1, asr #31
    |  ins_arithfallback bne
    |.else
    |  intins CARG1, CARG1, CARG3
    |  ins_arithfallback bvs
    |.endif
    |4:
    |   ins_next2
    |  strd CARG12, [BASE, RA]
    |   ins_next3
    |5:  // FP variant.
    |  ins_arithfallback ins_arithcheck_num
    |  bl fpcall
    |   ins_next1
    |  b <4
    |.endmacro
    |
    |.macro ins_arithfp, fpcall
    |  ins_arithpre
    ||if (op == BC_MODVN) {
    |  ->BC_MODVN_Z:
    ||}
    |  ins_arithfallback ins_arithcheck_num
    |  bl fpcall
    |   ins_next1
    |   ins_next2
    |  strd CARG12, [BASE, RA]
    |   ins_next3
    |.endmacro

  case BC_ADDVN: case BC_ADDNV: case BC_ADDVV:
    |  ins_arithdn adds, extern __aeabi_dadd
    break;
  case BC_SUBVN: case BC_SUBNV: case BC_SUBVV:
    |  ins_arithdn subs, extern __aeabi_dsub
    break;
  case BC_MULVN: case BC_MULNV: case BC_MULVV:
    |  ins_arithdn smull, extern __aeabi_dmul
    break;
  case BC_DIVVN: case BC_DIVNV: case BC_DIVVV:
    |  ins_arithfp extern __aeabi_ddiv
    break;
  case BC_MODVN:
    |  // NYI: integer arithmetic.
    |  // Note: __aeabi_idivmod is unsuitable. It uses trunc, not floor.
    |  ins_arithfp ->vm_mod
    break;
  case BC_MODNV: case BC_MODVV:
    |  ins_arithpre
    |  b ->BC_MODVN_Z
    break;
  case BC_POW:
    |  // NYI: (partial) integer arithmetic.
    |  ins_arithfp extern pow
    break;

  case BC_CAT:
    |  NYI
    break;

  /* -- Constant ops ------------------------------------------------------ */

  case BC_KSTR:
    |  // RA = dst*8, RC = str_const (~)
    |  mvn RC, RC
    |   ins_next1
    |  ldr CARG1, [KBASE, RC, lsl #2]
    |   ins_next2
    |  mvn CARG2, #~LJ_TSTR
    |  strd CARG12, [BASE, RA]
    |   ins_next3
    break;
  case BC_KCDATA:
#if LJ_HASFFI
    |  NYI
#endif
    break;
  case BC_KSHORT:
    |  // RA = dst*8, (RC = int16_literal)
    |  mov CARG1, INS, asr #16			// Refetch sign-extended reg.
    |  mvn CARG2, #~LJ_TISNUM
    |   ins_next1
    |   ins_next2
    |  strd CARG12, [BASE, RA]
    |   ins_next3
    break;
  case BC_KNUM:
    |  // RA = dst*8, RC = num_const
    |  lsl RC, RC, #3
    |   ins_next1
    |  ldrd CARG12, [KBASE, RC]
    |   ins_next2
    |  strd CARG12, [BASE, RA]
    |   ins_next3
    break;
  case BC_KPRI:
    |  // RA = dst*8, RC = primitive_type (~)
    |  add RA, BASE, RA
    |  mvn RC, RC
    |   ins_next1
    |   ins_next2
    |  str RC, [RA, #4]
    |   ins_next3
    break;
  case BC_KNIL:
    |  // RA = base*8, RC = end
    |  add RA, BASE, RA
    |   add RC, BASE, RC, lsl #3
    |  mvn CARG1, #~LJ_TNIL
    |  str CARG1, [RA, #4]
    |   add RA, RA, #8
    |1:
    |  str CARG1, [RA, #4]
    |  cmp RA, RC
    |   add RA, RA, #8
    |  blt <1
    |  ins_next_
    break;

  /* -- Upvalue and function ops ------------------------------------------ */

  case BC_UGET:
    |  NYI
    break;
  case BC_USETV:
    |  NYI
    break;
  case BC_USETS:
    |  NYI
    break;
  case BC_USETN:
    |  NYI
    break;
  case BC_USETP:
    |  NYI
    break;

  case BC_UCLO:
    |  NYI
    break;

  case BC_FNEW:
    |  NYI
    break;

  /* -- Table ops --------------------------------------------------------- */

  case BC_TNEW:
  case BC_TDUP:
    |  // RA = dst*8, RC = (hbits|asize) | tab_const (~)
    if (op == BC_TDUP) {
      |  mvn RC, RC
    }
    |  ldr CARG3, [DISPATCH, #DISPATCH_GL(gc.total)]
    |   ldr CARG4, [DISPATCH, #DISPATCH_GL(gc.threshold)]
    |    str BASE, L->base
    |    str PC, SAVE_PC
    |  cmp CARG3, CARG4
    |  bhs >5
    |1:
    |  mov CARG1, L
    if (op == BC_TNEW) {
      |  lsl CARG2, RC, #21
      |   lsr CARG3, RC, #11
      |  asr RC, CARG2, #21
      |  lsr CARG2, CARG2, #21
      |  cmn RC, #1
      |  addeq CARG2, CARG2, #2
      |  bl extern lj_tab_new  // (lua_State *L, int32_t asize, uint32_t hbits)
      |  // Returns GCtab *.
    } else {
      |  ldr CARG2, [KBASE, RC, lsl #2]
      |  bl extern lj_tab_dup  // (lua_State *L, Table *kt)
      |  // Returns GCtab *.
    }
    |  ldr BASE, L->base
    |  mvn CARG2, #~LJ_TTAB
    |   ins_next1
    |   ins_next2
    |  strd CARG12, [BASE, RA]
    |   ins_next3
    |5:
    |  bl extern lj_gc_step_fixtop  // (lua_State *L)
    |  b <1
    break;

  case BC_GGET:
    |  // RA = dst*8, RC = str_const (~)
  case BC_GSET:
    |  // RA = dst*8, RC = str_const (~)
    |  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    |   mvn RC, RC
    |  ldr TAB:CARG1, LFUNC:CARG2->env
    |   ldr STR:RC, [KBASE, RC, lsl #2]
    if (op == BC_GGET) {
      |  b ->BC_TGETS_Z
    } else {
      |  b ->BC_TSETS_Z
    }
    break;

  case BC_TGETV:
    |  decode_RB8 RB, INS
    |   decode_RC8 RC, INS
    |  // RA = dst*8, RB = table*8, RC = key*8
    |  ldrd TAB:CARG12, [BASE, RB]
    |   ldrd CARG34, [BASE, RC]
    |  checktab CARG2, ->vmeta_tgetv  // STALL: load CARG12.
    |   checktp CARG4, LJ_TISNUM	// Integer key?
    |  ldreq CARG4, TAB:CARG1->array
    |    ldreq CARG2, TAB:CARG1->asize
    |   bne >9
    |
    |  add CARG4, CARG4, CARG3, lsl #3
    |    cmp CARG3, CARG2		// In array part?
    |  ldrdlo CARG34, [CARG4]
    |    bhs ->vmeta_tgetv
    |   ins_next1
    |  checktp CARG4, LJ_TNIL
    |  beq >5
    |1:
    |   ins_next2
    |  strd CARG34, [BASE, RA]
    |   ins_next3
    |
    |5:  // Check for __index if table value is nil.
    |  ldr TAB:CARG2, TAB:CARG1->metatable
    |  cmp TAB:CARG2, #0
    |  beq <1				// No metatable: done.
    |  ldrb CARG2, TAB:CARG2->nomm
    |  tst CARG2, #1<<MM_index
    |  bne <1				// 'no __index' flag set: done.
    |  b ->vmeta_tgetv
    |
    |9:
    |  checktp CARG4, LJ_TSTR		// String key?
    |   moveq STR:RC, CARG3
    |  beq ->BC_TGETS_Z
    |  b ->vmeta_tgetv
    break;
  case BC_TGETS:
    |  decode_RB8 RB, INS
    |   and RC, RC, #255
    |  // RA = dst*8, RB = table*8, RC = str_const (~)
    |  ldrd CARG12, [BASE, RB]
    |   mvn RC, RC
    |   ldr STR:RC, [KBASE, RC, lsl #2]  // STALL: early RC.
    |  checktab CARG2, ->vmeta_tgets1
    |->BC_TGETS_Z:
    |  // (TAB:RB =) TAB:CARG1 = GCtab *, STR:RC = GCstr *, RA = dst*8
    |  ldr CARG3, TAB:CARG1->hmask
    |   ldr CARG4, STR:RC->hash
    |    ldr NODE:INS, TAB:CARG1->node
    |     mov TAB:RB, TAB:CARG1
    |  and CARG3, CARG3, CARG4			// idx = str->hash & tab->hmask
    |  add CARG3, CARG3, CARG3, lsl #1
    |    add NODE:INS, NODE:INS, CARG3, lsl #3	// node = tab->node + idx*3*8
    |1:
    |  ldrd CARG12, NODE:INS->key  // STALL: early NODE:INS.
    |   ldrd CARG34, NODE:INS->val
    |    ldr NODE:INS, NODE:INS->next
    |  cmp CARG1, STR:RC
    |  checktpeq CARG2, LJ_TSTR
    |  bne >4
    |   checktp CARG4, LJ_TNIL
    |   beq >5
    |3:
    |   ins_next1
    |   ins_next2
    |  strd CARG34, [BASE, RA]
    |   ins_next3
    |
    |4:  // Follow hash chain.
    |  cmp NODE:INS, #0
    |  bne <1
    |  // End of hash chain: key not found, nil result.
    |
    |5:  // Check for __index if table value is nil.
    |  ldr TAB:CARG1, TAB:RB->metatable
    |   mov CARG3, #0  // Optional clear of undef. value (during load stall).
    |   mvn CARG4, #~LJ_TNIL
    |  cmp TAB:CARG1, #0
    |  beq <3				// No metatable: done.
    |  ldrb CARG2, TAB:CARG1->nomm
    |  tst CARG2, #1<<MM_index
    |  bne <3				// 'no __index' flag set: done.
    |  b ->vmeta_tgets
    break;
  case BC_TGETB:
    |  decode_RB8 RB, INS
    |   and RC, RC, #255
    |  // RA = dst*8, RB = table*8, RC = index
    |  ldrd CARG12, [BASE, RB]
    |  checktab CARG2, ->vmeta_tgetb  // STALL: load CARG12.
    |   ldr CARG3, TAB:CARG1->asize
    |  ldr CARG4, TAB:CARG1->array
    |  lsl CARG2, RC, #3
    |   cmp RC, CARG3
    |  ldrdlo CARG34, [CARG4, CARG2]
    |   bhs ->vmeta_tgetb
    |   ins_next1  // Overwrites RB!
    |  checktp CARG4, LJ_TNIL
    |  beq >5
    |1:
    |   ins_next2
    |  strd CARG34, [BASE, RA]
    |   ins_next3
    |
    |5:  // Check for __index if table value is nil.
    |  ldr TAB:CARG2, TAB:CARG1->metatable
    |  cmp TAB:CARG2, #0
    |  beq <1				// No metatable: done.
    |  ldrb CARG2, TAB:CARG2->nomm
    |  tst CARG2, #1<<MM_index
    |  bne <1				// 'no __index' flag set: done.
    |  b ->vmeta_tgetb
    break;

  case BC_TSETV:
    |  decode_RB8 RB, INS
    |   decode_RC8 RC, INS
    |  // RA = src*8, RB = table*8, RC = key*8
    |  ldrd TAB:CARG12, [BASE, RB]
    |   ldrd CARG34, [BASE, RC]
    |  checktab CARG2, ->vmeta_tsetv  // STALL: load CARG12.
    |   checktp CARG4, LJ_TISNUM	// Integer key?
    |  ldreq CARG2, TAB:CARG1->array
    |    ldreq CARG4, TAB:CARG1->asize
    |   bne >9
    |
    |  add CARG2, CARG2, CARG3, lsl #3
    |    cmp CARG3, CARG4		// In array part?
    |  ldrlo INS, [CARG2, #4]
    |    bhs ->vmeta_tsetv
    |   ins_next1  // Overwrites RB!
    |  checktp INS, LJ_TNIL
    |  ldrb INS, TAB:CARG1->marked
    |   ldrd CARG34, [BASE, RA]
    |  beq >5
    |1:
    |  tst INS, #LJ_GC_BLACK		// isblack(table)
    |   strd CARG34, [CARG2]
    |  bne >7
    |2:
    |   ins_next2
    |   ins_next3
    |
    |5:  // Check for __newindex if previous value is nil.
    |  ldr TAB:RA, TAB:CARG1->metatable
    |  cmp TAB:RA, #0
    |  beq <1				// No metatable: done.
    |  ldrb RA, TAB:RA->nomm
    |  tst RA, #1<<MM_newindex
    |  bne <1				// 'no __newindex' flag set: done.
    |  ldr INS, [PC, #-4]		// Restore RA.
    |  decode_RA8 RA, INS
    |  b ->vmeta_tsetv
    |
    |7:  // Possible table write barrier for the value. Skip valiswhite check.
    |  barrierback TAB:CARG1, INS, CARG3
    |  b <2
    |
    |9:
    |  checktp CARG4, LJ_TSTR		// String key?
    |   moveq STR:RC, CARG3
    |  beq ->BC_TSETS_Z
    |  b ->vmeta_tsetv
    break;
  case BC_TSETS:
    |  decode_RB8 RB, INS
    |   and RC, RC, #255
    |  // RA = src*8, RB = table*8, RC = str_const (~)
    |  ldrd CARG12, [BASE, RB]
    |   mvn RC, RC
    |   ldr STR:RC, [KBASE, RC, lsl #2]  // STALL: early RC.
    |  checktab CARG2, ->vmeta_tsets1
    |->BC_TSETS_Z:
    |  // (TAB:RB =) TAB:CARG1 = GCtab *, STR:RC = GCstr *, RA = dst*8
    |  ldr CARG3, TAB:CARG1->hmask
    |   ldr CARG4, STR:RC->hash
    |    ldr NODE:INS, TAB:CARG1->node
    |     mov TAB:RB, TAB:CARG1
    |  and CARG3, CARG3, CARG4			// idx = str->hash & tab->hmask
    |  add CARG3, CARG3, CARG3, lsl #1
    |    add NODE:INS, NODE:INS, CARG3, lsl #3	// node = tab->node + idx*3*8
    |1:
    |  ldrd CARG12, NODE:INS->key  // STALL: early NODE:INS.
    |   ldr CARG4, NODE:INS->val.it
    |    ldr NODE:CARG3, NODE:INS->next
    |  cmp CARG1, STR:RC
    |  checktpeq CARG2, LJ_TSTR
    |  bne >5
    |  ldrb CARG2, TAB:RB->marked
    |   checktp CARG4, LJ_TNIL		// Key found, but nil value?
    |    ldrd CARG34, [BASE, RA]
    |   beq >4
    |2:
    |  tst CARG2, #LJ_GC_BLACK		// isblack(table)
    |    strd CARG34, NODE:INS->val
    |  bne >7
    |3:
    |   ins_next
    |
    |4:  // Check for __newindex if previous value is nil.
    |  ldr TAB:CARG1, TAB:RB->metatable
    |  cmp TAB:CARG1, #0
    |  beq <2				// No metatable: done.
    |  ldrb CARG1, TAB:CARG1->nomm
    |  tst CARG1, #1<<MM_newindex
    |  bne <2				// 'no __newindex' flag set: done.
    |  b ->vmeta_tsets
    |
    |5:  // Follow hash chain.
    |  movs NODE:INS, NODE:CARG3
    |  bne <1
    |  // End of hash chain: key not found, add a new one.
    |
    |  // But check for __newindex first.
    |  ldr TAB:CARG1, TAB:RB->metatable
    |   mov CARG3, TMPDp
    |   str PC, SAVE_PC
    |  cmp TAB:CARG1, #0		// No metatable: continue.
    |   str BASE, L->base
    |  ldrbne CARG2, TAB:CARG1->nomm
    |   mov CARG1, L
    |  beq >6
    |  tst CARG2, #1<<MM_newindex
    |  beq ->vmeta_tsets		// 'no __newindex' flag NOT set: check.
    |6:
    |  mvn CARG4, #~LJ_TSTR
    |   str STR:RC, TMPDlo
    |   mov CARG2, TAB:RB
    |  str CARG4, TMPDhi
    |  bl extern lj_tab_newkey		// (lua_State *L, GCtab *t, TValue *k)
    |  // Returns TValue *.
    |  ldr BASE, L->base
    |  ldrd CARG34, [BASE, RA]
    |  strd CARG34, [CRET1]
    |  b <3				// No 2nd write barrier needed.
    |
    |7:  // Possible table write barrier for the value. Skip valiswhite check.
    |  barrierback TAB:CARG1, CARG2, CARG3
    |  b <3
    break;
  case BC_TSETB:
    |  decode_RB8 RB, INS
    |   and RC, RC, #255
    |  // RA = src*8, RB = table*8, RC = index
    |  ldrd CARG12, [BASE, RB]
    |  checktab CARG2, ->vmeta_tsetb  // STALL: load CARG12.
    |   ldr CARG3, TAB:CARG1->asize
    |  ldr RB, TAB:CARG1->array
    |  lsl CARG2, RC, #3
    |   cmp RC, CARG3
    |  ldrdlo CARG34, [CARG2, RB]!
    |   bhs ->vmeta_tsetb
    |   ins_next1  // Overwrites RB!
    |  checktp CARG4, LJ_TNIL
    |  ldrb INS, TAB:CARG1->marked
    |   ldrd CARG34, [BASE, RA]
    |  beq >5
    |1:
    |  tst INS, #LJ_GC_BLACK		// isblack(table)
    |    strd CARG34, [CARG2]
    |  bne >7
    |2:
    |   ins_next2
    |   ins_next3
    |
    |5:  // Check for __newindex if previous value is nil.
    |  ldr TAB:RA, TAB:CARG1->metatable
    |  cmp TAB:RA, #0
    |  beq <1				// No metatable: done.
    |  ldrb RA, TAB:RA->nomm
    |  tst RA, #1<<MM_newindex
    |  bne <1				// 'no __newindex' flag set: done.
    |  ldr INS, [PC, #-4]		// Restore INS.
    |  b ->vmeta_tsetb
    |
    |7:  // Possible table write barrier for the value. Skip valiswhite check.
    |  barrierback TAB:CARG1, INS, CARG3
    |  b <2
    break;

  case BC_TSETM:
    |  NYI
    break;

  /* -- Calls and vararg handling ----------------------------------------- */

  case BC_CALLM:
    |  // RA = base*8, (RB = nresults+1,) RC = extra_nargs
    |  ldr CARG1, SAVE_MULTRES
    |  decode_RC8 NARGS8:RC, INS
    |  add NARGS8:RC, NARGS8:RC, CARG1
    |  b ->BC_CALL_Z
    break;
  case BC_CALL:
    |  // RA = base*8, (RB = nresults+1,) RC = nargs+1
    |  decode_RC8 NARGS8:RC, INS
    |->BC_CALL_Z:
    |  mov RB, BASE			// Save old BASE for vmeta_call.
    |  ldrd CARG34, [BASE, RA]!
    |   sub NARGS8:RC, NARGS8:RC, #8
    |   add BASE, BASE, #8
    |  checkfunc CARG4, ->vmeta_call
    |  ins_call
    break;

  case BC_CALLMT:
    |  NYI
    break;
  case BC_CALLT:
    |  NYI
    break;

  case BC_ITERC:
    |  // RA = base*8, (RB = nresults+1, RC = nargs+1 (2+1))
    |  add RA, BASE, RA
    |   mov RB, BASE			// Save old BASE for vmeta_call.
    |  ldrd CARG34, [RA, #-16]
    |   ldrd CARG12, [RA, #-8]
    |    add BASE, RA, #8
    |  strd CARG34, [RA, #8]		// Copy state.
    |   strd CARG12, [RA, #16]		// Copy control var.
    |  // STALL: locked CARG34.
    |  ldrd LFUNC:CARG34, [RA, #-24]
    |    mov NARGS8:RC, #16		// Iterators get 2 arguments.
    |  // STALL: load CARG34.
    |  strd LFUNC:CARG34, [RA]		// Copy callable.
    |  checkfunc CARG4, ->vmeta_call
    |  ins_call
    break;

  case BC_ITERN:
    |  // RA = base*8, (RB = nresults+1, RC = nargs+1 (2+1))
#if LJ_HASJIT
    |  // NYI: add hotloop, record BC_ITERN.
#endif
    |  add RA, BASE, RA
    |  ldr TAB:RB, [RA, #-16]
    |  ldr CARG1, [RA, #-8]		// Get index from control var.
    |  ldr INS, TAB:RB->asize
    |   ldr CARG2, TAB:RB->array
    |    add PC, PC, #4
    |1:  // Traverse array part.
    |  subs RC, CARG1, INS
    |   add CARG3, CARG2, CARG1, lsl #3
    |  bhs >5				// Index points after array part?
    |   ldrd CARG34, [CARG3]
    |   checktp CARG4, LJ_TNIL
    |   addeq CARG1, CARG1, #1		// Skip holes in array part.
    |   beq <1
    |  ldrh RC, [PC, #-2]
    |   mvn CARG2, #~LJ_TISNUM
    |    strd CARG34, [RA, #8]
    |  add RC, PC, RC, lsl #2
    |    add RB, CARG1, #1
    |   strd CARG12, [RA]
    |  sub PC, RC, #0x20000
    |    str RB, [RA, #-8]		// Update control var.
    |3:
    |  ins_next
    |
    |5:  // Traverse hash part.
    |  ldr CARG4, TAB:RB->hmask
    |   ldr NODE:RB, TAB:RB->node
    |6:
    |   add CARG1, RC, RC, lsl #1
    |  cmp RC, CARG4			// End of iteration? Branch to ITERL+1.
    |   add NODE:CARG3, NODE:RB, CARG1, lsl #3  // node = tab->node + idx*3*8
    |  bhi <3
    |   ldrd CARG12, NODE:CARG3->val
    |   checktp CARG2, LJ_TNIL
    |   add RC, RC, #1
    |   beq <6				// Skip holes in hash part.
    |  ldrh RB, [PC, #-2]
    |   add RC, RC, INS
    |    ldrd CARG34, NODE:CARG3->key
    |   str RC, [RA, #-8]		// Update control var.
    |   strd CARG12, [RA, #8]
    |  add RC, PC, RB, lsl #2
    |  sub PC, RC, #0x20000
    |    strd CARG34, [RA]
    |  b <3
    break;

  case BC_ISNEXT:
    |  // RA = base*8, RD = target (points to ITERN)
    |  add RA, BASE, RA
    |     add RC, PC, RC, lsl #2
    |  ldrd CFUNC:CARG12, [RA, #-24]
    |   ldr CARG3, [RA, #-12]
    |    ldr CARG4, [RA, #-4]
    |  checktp CARG2, LJ_TFUNC
    |  ldrbeq CARG1, CFUNC:CARG1->ffid
    |   checktpeq CARG3, LJ_TTAB
    |    checktpeq CARG4, LJ_TNIL
    |  cmpeq CARG1, #FF_next_N
    |     subeq PC, RC, #0x20000
    |  bne >5
    |   ins_next1
    |   ins_next2
    |  mov CARG1, #0
    |  str CARG1, [RA, #-8]		// Initialize control var.
    |1:
    |   ins_next3
    |5:  // Despecialize bytecode if any of the checks fail.
    |  mov CARG1, #BC_JMP
    |   mov OP, #BC_ITERC
    |  strb CARG1, [PC, #-4]
    |   sub PC, RC, #0x20000
    |   strb OP, [PC]			// Subsumes ins_next1.
    |   ins_next2
    |  b <1
    break;

  case BC_VARG:
    |  NYI
    break;

  /* -- Returns ----------------------------------------------------------- */

  case BC_RETM:
    |  // RA = results*8, RC = extra results
    |  ldr CARG1, SAVE_MULTRES
    |   ldr PC, [BASE, FRAME_PC]
    |    add RA, BASE, RA
    |  add RC, CARG1, RC, lsl #3
    |  b ->BC_RETM_Z
    break;

  case BC_RET:
    |  // RA = results*8, RC = nresults+1
    |  ldr PC, [BASE, FRAME_PC]
    |   lsl RC, RC, #3
    |    add RA, BASE, RA
    |->BC_RETM_Z:
    |   str RC, SAVE_MULTRES
    |1:
    |  ands CARG1, PC, #FRAME_TYPE
    |   eor CARG2, PC, #FRAME_VARG
    |  bne ->BC_RETV2_Z
    |
    |->BC_RET_Z:
    |  // BASE = base, RA = resultptr, RC = (nresults+1)*8, PC = return
    |  ldr INS, [PC, #-4]
    |  subs CARG4, RC, #8
    |   sub CARG3, BASE, #8
    |  beq >3
    |2:
    |  ldrd CARG12, [RA], #8
    |   add BASE, BASE, #8
    |   subs CARG4, CARG4, #8
    |  strd CARG12, [BASE, #-16]
    |   bne <2
    |3:
    |  decode_RA8 RA, INS
    |  sub BASE, CARG3, RA
    |   decode_RB8 RB, INS
    |  ldr LFUNC:CARG1, [BASE, FRAME_FUNC]
    |5:
    |  cmp RB, RC			// More results expected?
    |  bhi >6
    |  ldr CARG2, LFUNC:CARG1->field_pc
    |   ins_next1
    |   ins_next2
    |  ldr KBASE, [CARG2, #PC2PROTO(k)]
    |   ins_next3
    |
    |6:  // Fill up results with nil.
    |  mvn CARG2, #~LJ_TNIL
    |  sub BASE, BASE, #8
    |   add RC, RC, #8
    |  str CARG2, [BASE, #-12]
    |  b <5
    |
    |->BC_RETV1_Z:  // Non-standard return case.
    |  add RA, BASE, RA
    |->BC_RETV2_Z:
    |  tst CARG2, #FRAME_TYPEP
    |  bne ->vm_return
    |  // Return from vararg function: relocate BASE down.
    |  sub BASE, BASE, CARG2
    |  ldr PC, [BASE, FRAME_PC]
    |  b <1
    break;

  case BC_RET0: case BC_RET1:
    |  // RA = results*8, RC = nresults+1
    |  ldr PC, [BASE, FRAME_PC]
    |   lsl RC, RC, #3
    |   str RC, SAVE_MULTRES
    |  ands CARG1, PC, #FRAME_TYPE
    |   eor CARG2, PC, #FRAME_VARG
    |   ldreq INS, [PC, #-4]
    |  bne ->BC_RETV1_Z
    if (op == BC_RET1) {
      |  ldrd CARG12, [BASE, RA]
    }
    |  sub CARG4, BASE, #8
    |   decode_RA8 RA, INS
    if (op == BC_RET1) {
      |  strd CARG12, [CARG4]
    }
    |  sub BASE, CARG4, RA
    |   decode_RB8 RB, INS
    |  ldr LFUNC:CARG1, [BASE, FRAME_FUNC]
    |5:
    |  cmp RB, RC
    |  bhi >6
    |  ldr CARG2, LFUNC:CARG1->field_pc
    |   ins_next1
    |   ins_next2
    |  ldr KBASE, [CARG2, #PC2PROTO(k)]
    |   ins_next3
    |
    |6:  // Fill up results with nil.
    |  sub CARG2, CARG4, #4
    |  mvn CARG3, #~LJ_TNIL
    |  str CARG3, [CARG2, RC]
    |  add RC, RC, #8
    |  b <5
    break;

  /* -- Loops and branches ------------------------------------------------ */

  |.define FOR_IDX,  [RA];      .define FOR_TIDX,  [RA, #4]
  |.define FOR_STOP, [RA, #8];  .define FOR_TSTOP, [RA, #12]
  |.define FOR_STEP, [RA, #16]; .define FOR_TSTEP, [RA, #20]
  |.define FOR_EXT,  [RA, #24]; .define FOR_TEXT,  [RA, #28]

  case BC_FORL:
#if LJ_HASJIT
    |  hotloop
#endif
    |  // Fall through. Assumes BC_IFORL follows.
    break;

  case BC_JFORI:
  case BC_JFORL:
#if !LJ_HASJIT
    break;
#endif
  case BC_FORI:
  case BC_IFORL:
    |  // RA = base*8, RC = target (after end of loop or start of loop)
    vk = (op == BC_IFORL || op == BC_JFORL);
    |  ldrd CARG12, [RA, BASE]!
    |   add RC, PC, RC, lsl #2
    if (!vk) {
      |  ldrd CARG34, FOR_STOP
      |   checktp CARG2, LJ_TISNUM
      |  ldr RB, FOR_TSTEP
      |   bne >5
      |  checktp CARG4, LJ_TISNUM
      |   ldr CARG4, FOR_STEP
      |  checktpeq RB, LJ_TISNUM
      |  bne ->vmeta_for
      |  cmp CARG4, #0
      |  blt >4
      |  cmp CARG1, CARG3
    } else {
      |  ldrd CARG34, FOR_STEP
      |   checktp CARG2, LJ_TISNUM
      |   bne >5
      |  adds CARG1, CARG1, CARG3
      |   ldr CARG4, FOR_STOP
      if (op == BC_IFORL) {
	|  addvs RC, PC, #0x20000		// Overflow: prevent branch.
      } else {
	|  NYI
      }
      |  cmp CARG3, #0
      |  blt >4
      |  cmp CARG1, CARG4
    }
    |1:
    if (op == BC_FORI) {
      |  subgt PC, RC, #0x20000
    } else if (op == BC_JFORI) {
      |  NYI
    } else if (op == BC_IFORL) {
      |  suble PC, RC, #0x20000
    } else {
      |  NYI
    }
    if (vk) {
      |  strd CARG12, FOR_IDX
    }
    |   ins_next1
    |   ins_next2
    |  strd CARG12, FOR_EXT
    |3:
    |   ins_next3
    |
    |4:  // Invert check for negative step.
    if (!vk) {
      |  cmp CARG3, CARG1
    } else {
      |  cmp CARG4, CARG1
    }
    |  b <1
    |
    |5:  // FP loop.
    if (!vk) {
      |  cmnlo CARG4, #-LJ_TISNUM
      |  cmnlo RB, #-LJ_TISNUM
      |  bhs ->vmeta_for
      |  cmp RB, #0
      |   strd CARG12, FOR_IDX
      |  blt >8
    } else {
      |  cmp CARG4, #0
      |  blt >8
      |  bl extern __aeabi_dadd
      |   strd CARG12, FOR_IDX
      |  ldrd CARG34, FOR_STOP
      |   strd CARG12, FOR_EXT
    }
    |6:
    |  bl extern __aeabi_cdcmple
    if (op == BC_FORI) {
      |  subhi PC, RC, #0x20000
    } else if (op == BC_JFORI) {
      |  NYI
    } else if (op == BC_IFORL) {
      |  subls PC, RC, #0x20000
    } else {
      |  NYI
    }
    |  ins_next1
    |  ins_next2
    |  b <3
    |
    |8:  // Invert check for negative step.
    if (vk) {
      |  bl extern __aeabi_dadd
      |  strd CARG12, FOR_IDX
      |  strd CARG12, FOR_EXT
    }
    |  mov CARG3, CARG1
    |  mov CARG4, CARG2
    |  ldrd CARG12, FOR_STOP
    |  b <6
    break;

  case BC_ITERL:
#if LJ_HASJIT
    |  hotloop
#endif
    |  // Fall through. Assumes BC_IITERL follows.
    break;

  case BC_JITERL:
#if !LJ_HASJIT
    break;
#endif
  case BC_IITERL:
    |  // RA = base*8, RC = target
    |  ldrd CARG12, [RA, BASE]!
    if (op == BC_JITERL) {
      |  NYI
    } else {
      |   add RC, PC, RC, lsl #2
      |  // STALL: load CARG12.
      |  cmn CARG2, #-LJ_TNIL		// Stop if iterator returned nil.
      |  subne PC, RC, #0x20000		// Otherwise save control var + branch.
      |  strdne CARG12, [RA, #-8]
    }
    |  ins_next
    break;

  case BC_LOOP:
    |  // RA = base*8, RC = target (loop extent)
    |  // Note: RA/RC is only used by trace recorder to determine scope/extent
    |  // This opcode does NOT jump, it's only purpose is to detect a hot loop.
#if LJ_HASJIT
    |  hotloop
#endif
    |  // Fall through. Assumes BC_ILOOP follows.
    break;

  case BC_ILOOP:
    |  // RA = base*8, RC = target (loop extent)
    |  ins_next
    break;

  case BC_JLOOP:
#if LJ_HASJIT
    |  NYI
#endif
    break;

  case BC_JMP:
    |  // RA = base*8 (only used by trace recorder), RC = target
    |  add RC, PC, RC, lsl #2
    |  sub PC, RC, #0x20000
    |  ins_next
    break;

  /* -- Function headers -------------------------------------------------- */

  case BC_FUNCF:
#if LJ_HASJIT
    |  hotcall
#endif
  case BC_FUNCV:  /* NYI: compiled vararg functions. */
    |  // Fall through. Assumes BC_IFUNCF/BC_IFUNCV follow.
    break;

  case BC_JFUNCF:
#if !LJ_HASJIT
    break;
#endif
  case BC_IFUNCF:
    |  // BASE = new base, RA = BASE+framesize*8, CARG3 = LFUNC, RC = nargs*8
    |  ldr CARG1, L->maxstack
    |   ldrb CARG2, [PC, #-4+PC2PROTO(numparams)]
    |    ldr KBASE, [PC, #-4+PC2PROTO(k)]
    |  cmp RA, CARG1
    |  bhi ->vm_growstack_l
    |  ins_next1
    |  ins_next2
    |2:
    |  cmp NARGS8:RC, CARG2, lsl #3	// Check for missing parameters.
    |  ble >3
    if (op == BC_JFUNCF) {
      |  NYI
    } else {
      |  ins_next3
    }
    |
    |3:  // Clear missing parameters.
    |  mvn CARG1, #~LJ_TNIL
    |  str CARG1, [BASE, NARGS8:RC]
    |  add NARGS8:RC, NARGS8:RC, #8
    |  b <2
    break;

  case BC_JFUNCV:
#if !LJ_HASJIT
    break;
#endif
    |  NYI  // NYI: compiled vararg functions
    break;  /* NYI: compiled vararg functions. */

  case BC_IFUNCV:
    |  // BASE = new base, RA = BASE+framesize*8, CARG3 = LFUNC, RC = nargs*8
    |  ldr CARG1, L->maxstack
    |   add CARG4, BASE, RC
    |  add RA, RA, RC
    |   str LFUNC:CARG3, [CARG4]	// Store copy of LFUNC.
    |   add CARG2, RC, #8+FRAME_VARG
    |    ldr KBASE, [PC, #-4+PC2PROTO(k)]
    |  cmp RA, CARG1
    |   str CARG2, [CARG4, #4]		// Store delta + FRAME_VARG.
    |  bhs ->vm_growstack_l
    |  ldrb RB, [PC, #-4+PC2PROTO(numparams)]
    |   mov RA, BASE
    |   mov RC, CARG4
    |  cmp RB, #0
    |   add BASE, CARG4, #8
    |  beq >3
    |  mvn CARG3, #~LJ_TNIL
    |1:
    |  cmp RA, RC			// Less args than parameters?
    |   ldrdlo CARG12, [RA], #8
    |   movhs CARG2, CARG3
    |    strlo CARG3, [RA, #-4]		// Clear old fixarg slot (help the GC).
    |2:
    |  subs RB, RB, #1
    |   strd CARG12, [CARG4, #8]!
    |  bne <1
    |3:
    |  ins_next
    break;

  case BC_FUNCC:
  case BC_FUNCCW:
    |  // BASE = new base, RA = BASE+framesize*8, CARG3 = CFUNC, RC = nargs*8
    if (op == BC_FUNCC) {
      |  ldr CARG4, CFUNC:CARG3->f
    } else {
      |  ldr CARG4, [DISPATCH, #DISPATCH_GL(wrapf)]
    }
    |   add CARG2, RA, NARGS8:RC
    |   ldr CARG1, L->maxstack
    |  add RC, BASE, NARGS8:RC
    |    str BASE, L->base
    |   cmp CARG2, CARG1
    |  str RC, L->top
    if (op == BC_FUNCCW) {
      |  ldr CARG2, CFUNC:CARG3->f
    }
    |    mv_vmstate CARG3, C
    |  mov CARG1, L
    |   bhi ->vm_growstack_c		// Need to grow stack.
    |    st_vmstate CARG3
    |  blx CARG4			// (lua_State *L [, lua_CFunction f])
    |  // Returns nresults.
    |  ldr BASE, L->base
    |    mv_vmstate CARG3, INTERP
    |   ldr CRET2, L->top
    |   lsl RC, CRET1, #3
    |    st_vmstate CARG3
    |  ldr PC, [BASE, FRAME_PC]
    |   sub RA, CRET2, RC		// RA = L->top - nresults*8
    |  b ->vm_returnc
    break;

  /* ---------------------------------------------------------------------- */

  default:
    fprintf(stderr, "Error: undefined opcode BC_%s\n", bc_names[op]);
    exit(2);
    break;
  }
}

static int build_backend(BuildCtx *ctx)
{
  int op;

  dasm_growpc(Dst, BC__MAX);

  build_subroutines(ctx);

  |.code_op
  for (op = 0; op < BC__MAX; op++)
    build_ins(ctx, (BCOp)op, op);

  return BC__MAX;
}

/* Emit pseudo frame-info for all assembler functions. */
static void emit_asm_debug(BuildCtx *ctx)
{
  int i;
  switch (ctx->mode) {
  case BUILD_elfasm:
    fprintf(ctx->fp, "\t.section .debug_frame,\"\",%%progbits\n");
    fprintf(ctx->fp,
	".Lframe0:\n"
	"\t.long .LECIE0-.LSCIE0\n"
	".LSCIE0:\n"
	"\t.long 0xffffffff\n"
	"\t.byte 0x1\n"
	"\t.string \"\"\n"
	"\t.uleb128 0x1\n"
	"\t.sleb128 -4\n"
	"\t.byte 0xe\n"				/* Return address is in lr. */
	"\t.byte 0xc\n\t.uleb128 0xd\n\t.uleb128 0\n"	/* def_cfa sp */
	"\t.align 2\n"
	".LECIE0:\n\n");
    fprintf(ctx->fp,
	".LSFDE0:\n"
	"\t.long .LEFDE0-.LASFDE0\n"
	".LASFDE0:\n"
	"\t.long .Lframe0\n"
	"\t.long .Lbegin\n"
	"\t.long %d\n"
	"\t.byte 0xe\n\t.uleb128 %d\n"		/* def_cfa_offset */
	"\t.byte 0x8e\n\t.uleb128 1\n",		/* Restore lr. */
	(int)ctx->codesz, CFRAME_SIZE);
    for (i = 11; i >= 4; i--)  /* Restore r4-r11. */
      fprintf(ctx->fp, "\t.byte %d\n\t.uleb128 %d\n", 0x80+i, 2+(11-i));
    fprintf(ctx->fp,
	"\t.align 2\n"
	".LEFDE0:\n\n");
    /* NYI: emit ARM.exidx. */
    break;
  default:
    break;
  }
}

