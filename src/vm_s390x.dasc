|// Low-level VM code for IBM z/Architecture (s390x) CPUs in LJ_GC64 mode.
|// Bytecode interpreter, fast functions and helper functions.
|// Copyright (C) 2005-2016 Mike Pall. See Copyright Notice in luajit.h
|
|// ELF ABI registers:
|// r0,r1       |                            | volatile |
|// r2          | parameter and return value | volatile |
|// r3-r5       | parameter                  | volatile |
|// r6          | parameter                  | saved    |
|// r7-r11      |                            | saved    |
|// r12         | GOT pointer  (needed?)     | saved    |
|// r13         | literal pool (needed?)     | saved    |
|// r14         | return address             | volatile |
|// r15         | stack pointer              | saved    |
|// f0,f2,f4,f6 | parameter and return value | volatile |
|// f1,f3,f5,f7 |                            | volatile |
|// f8-f15      |                            | saved    |
|// ar0,ar1     | TLS                        | volatile |
|// ar2-ar15    |                            | volatile |
|
|.arch s390x
|.section code_op, code_sub
|
|.actionlist build_actionlist
|.globals GLOB_
|.globalnames globnames
|.externnames extnames
|
|//-----------------------------------------------------------------------
|
|// Fixed register assignments for the interpreter, callee-saved.
|.define BASE,			r7	// Base of current Lua stack frame.
|.define KBASE,			r8	// Constants of current Lua function.
|.define PC,			r9	// Next PC.
|.define DISPATCH,		r10	// Opcode dispatch table.
|.define LREG,			r11	// Register holding lua_State (also in SAVE_L).
|
|// The following temporaries are not saved across C calls, except for RD.
|.define RA,			r0	// Cannot be dereferenced.
|.define RB,			r1
|.define RC,			r5	// Overlaps CARG4.
|.define RD,			r6	// Overlaps CARG5. Callee-saved.
|
|// Calling conventions. Also used as temporaries.
|.define CARG1,			r2
|.define CARG2,			r3
|.define CARG3,			r4
|.define CARG4,			r5
|.define CARG5,			r6
|
|.define FARG1,			f0
|.define FARG2,			f2
|.define FARG3,			f4
|.define FARG4,			f6
|
|.define CRET1,			r2
|
|.define OP,			r2
|.define TMP1,			r3
|
|// Stack layout while in interpreter. Must match with lj_frame.h.
|.define CFRAME_SPACE,	240	// Delta for sp, 8 byte aligned.
|
|// Register save area.
|.define SAVE_GPRS,	288(sp)	// Save area for r6-r15 (10*8 bytes).
|.define SAVE_GPRS_P,	48(sp)  // Save area for r6-r15 (10*8 bytes) in prologue (before stack frame is allocated).
|
|// Argument save area, each slot is 8-bytes (32-bit types are sign/zero extended).
|.define SAVE_ERRF,	280(sp) // Argument 4, in r5.
|.define SAVE_NRES,	272(sp)	// Argument 3, in r4.
|.define SAVE_CFRAME,	264(sp)	// Argument 2, in r3.
|.define SAVE_L,	256(sp)	// Argument 1, in r2.
|.define RESERVED,	248(sp)	// Reserved for compiler use.
|.define BACKCHAIN,	240(sp)	// <- sp entering interpreter.
|
|// Interpreter stack frame.
|.define SAVE_FPR15,	232(sp)
|.define SAVE_FPR14,	224(sp)
|.define SAVE_FPR13,	216(sp)
|.define SAVE_FPR12,	208(sp)
|.define SAVE_FPR11,	200(sp)
|.define SAVE_FPR10,	192(sp)
|.define SAVE_FPR9,	184(sp)
|.define SAVE_FPR8,	176(sp)
|.define SAVE_PC,	168(sp)
|.define SAVE_MULTRES,	160(sp)
|
|// Callee save area (allocated by interpreter).
|.define CALLEESAVE,	000(sp) // <- sp in interpreter.
|
|.macro saveregs
|  stmg r6, r15, SAVE_GPRS_P
|  lay sp, -CFRAME_SPACE(sp)	// Allocate stack frame.
|  // TODO: save backchain?
|  std f8, SAVE_FPR8		// f8-f15 are callee-saved.
|  std f9, SAVE_FPR9
|  std f10, SAVE_FPR10
|  std f11, SAVE_FPR11
|  std f12, SAVE_FPR12
|  std f13, SAVE_FPR13
|  std f14, SAVE_FPR14
|  std f15, SAVE_FPR15
|.endmacro
|
|.macro restoreregs
|  ld f8, SAVE_FPR8		// f8-f15 are callee-saved.
|  ld f9, SAVE_FPR9
|  ld f10, SAVE_FPR10
|  ld f11, SAVE_FPR11
|  ld f12, SAVE_FPR12
|  ld f13, SAVE_FPR13
|  ld f14, SAVE_FPR14
|  ld f15, SAVE_FPR15
|  lmg r6, r15, SAVE_GPRS	// Restores the stack pointer.
|.endmacro
|
|// Type definitions. Some of these are only used for documentation.
|.type L,		lua_State
|.type GL,		global_State
|.type TVALUE,		TValue
|.type GCOBJ,		GCobj
|.type STR,		GCstr
|.type TAB,		GCtab
|.type LFUNC,		GCfuncL
|.type CFUNC,		GCfuncC
|.type PROTO,		GCproto
|.type UPVAL,		GCupval
|.type NODE,		Node
|.type NARGS,		int
|.type TRACE,		GCtrace
|.type SBUF,		SBuf
|
|//-----------------------------------------------------------------------
|
|// Instruction headers.
|.macro ins_A; .endmacro
|.macro ins_AD; .endmacro
|.macro ins_AJ; .endmacro
|.macro ins_ABC; .endmacro
|.macro ins_AB_; .endmacro
|.macro ins_A_C; .endmacro
|.macro ins_AND; .endmacro
|
|// Instruction decode+dispatch.
|  // TODO: tune this, right now we always decode RA-D even if they aren't used.
|.macro ins_NEXT
|  l RD, (PC)
|  // 32                 63
|  // [  B |  C |  A | OP ]
|  // [    D    |  A | OP ]
|  llhr RA, RD
|  srl RA, #8
|  llcr OP, RD
|  srl RD, #16
|  lr RB, RD
|  srl RB, #8
|  llcr RC, RD
|  la PC, 4(PC)
|  llgfr TMP1, OP
|  sll TMP1, #3 // TMP1=OP*8
|  b 0(TMP1, DISPATCH)
|.endmacro
|
|// Instruction footer.
|.if 1
|  // Replicated dispatch. Less unpredictable branches, but higher I-Cache use.
|  .define ins_next, ins_NEXT
|  .define ins_next_, ins_NEXT
|.else
|  // Common dispatch. Lower I-Cache use, only one (very) unpredictable branch.
|  .macro ins_next
|    jmp ->ins_next
|  .endmacro
|  .macro ins_next_
|  ->ins_next:
|    ins_NEXT
|  .endmacro
|.endif
|
|// Assumes DISPATCH is relative to GL.
#define DISPATCH_GL(field)	(GG_DISP2G + (int)offsetof(global_State, field))
#define DISPATCH_J(field)	(GG_DISP2J + (int)offsetof(jit_State, field))

/* Generate subroutines used by opcodes and other parts of the VM. */
/* The .code_sub section should be last to help static branch prediction. */
static void build_subroutines(BuildCtx *ctx)
{
  |.code_sub
  |
  |//-----------------------------------------------------------------------
  |//-- Return handling ----------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_returnp:
  |
  |->vm_returnc:
  |
  |->vm_return:
  |
  |->vm_leave_cp:
  |  lg RA, SAVE_CFRAME			// Restore previous C frame.
  |  stg RA, L:LREG->cframe
  |  lghi CRET1, 0			// Ok return status for vm_pcall.
  |
  |->vm_leave_unw:
  |  restoreregs
  |  br r14
  |
  |->vm_unwind_yield:
  |
  |->vm_unwind_c:			// Unwind C stack, return from vm_pcall.
  |->vm_unwind_c_eh:			// Landing pad for external unwinder.
  |->vm_unwind_rethrow:
  |->vm_unwind_ff:			// Unwind C stack, return from ff pcall.
  |->vm_unwind_ff_eh:			// Landing pad for external unwinder.
  |
  |//-----------------------------------------------------------------------
  |//-- Grow stack for calls -----------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_growstack_c:			// Grow stack for C function.
  |
  |->vm_growstack_v:			// Grow stack for vararg Lua function.
  |
  |->vm_growstack_f:			// Grow stack for fixarg Lua function.
  |  // BASE = new base, RD = nargs+1, RB = L, PC = first PC
  |
  |//-----------------------------------------------------------------------
  |//-- Entry points into the assembler VM ---------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_resume:				// Setup C frame and resume thread.
  |
  |->vm_pcall:				// Setup protected C frame and enter VM.
  |
  |->vm_call:				// Setup C frame and enter VM.
  |
  |->vm_call_dispatch:
  |
  |->vm_call_dispatch_f:
  |
  |->vm_cpcall:				// Setup protected C frame, call C.
  |  // (lua_State *L, lua_CFunction func, void *ud, lua_CPFunction cp)
  |  saveregs
  |  lgr LREG, CARG1
  |  stg LREG, SAVE_L
  |  stg LREG, SAVE_PC			// Any value outside of bytecode is ok.
  |
  |  lg KBASE, L:LREG->stack		// Compute -savestack(L, L->top).
  |  sg KBASE, L:LREG->top
  |   lg DISPATCH, L:LREG->glref	// Setup pointer to dispatch table.
  |  lghi RA, 0
  |  stg RA, SAVE_ERRF			// No error function.
  |  stg KBASE, SAVE_NRES		// Neg. delta means cframe w/o frame.
  |   aghi DISPATCH, GG_G2DISP
  |  // Handler may change cframe_nres(L->cframe) or cframe_errfunc(L->cframe).
  |
  |  lg KBASE, L:LREG->cframe		// Add our C frame to cframe chain.
  |  stg KBASE, SAVE_CFRAME
  |  stg sp, L:LREG->cframe
  |  stg L:LREG, DISPATCH_GL(cur_L)(DISPATCH)
  |
  |  basr r14, CARG4			// (lua_State *L, lua_CFunction func, void *ud)
  |  // TValue * (new base) or NULL returned in r2 (CRET1/).
  |  cghi CRET1, 0
  |  je ->vm_leave_cp			// No base? Just remove C frame.
  |  stg r0, 0(r0)
  |
  |//-----------------------------------------------------------------------
  |//-- Metamethod handling ------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |//-- Continuation dispatch ----------------------------------------------
  |
  |->cont_dispatch:
  |
  |->cont_cat:				// BASE = base, RC = result, RB = mbase
  |
  |//-- Table indexing metamethods -----------------------------------------
  |
  |->vmeta_tgets:
  |
  |->vmeta_tgetb:
  |
  |->vmeta_tgetv:
  |->cont_ra:				// BASE = base, RC = result
  |
  |->vmeta_tgetr:
  |
  |//-----------------------------------------------------------------------
  |
  |->vmeta_tsets:
  |
  |->vmeta_tsetb:
  |
  |->vmeta_tsetv:
  |->cont_nop:				// BASE = base, (RC = result)
  |
  |->vmeta_tsetr:
  |
  |//-- Comparison metamethods ---------------------------------------------
  |
  |->cont_condt:			// BASE = base, RC = result
  |
  |->cont_condf:			// BASE = base, RC = result
  |
  |->vmeta_equal:
  |
  |->vmeta_equal_cd:
  |
  |->vmeta_istype:
  |
  |//-- Arithmetic metamethods ---------------------------------------------
  |
  |->vmeta_arith_vno:
  |->vmeta_arith_vn:
  |
  |->vmeta_arith_nvo:
  |->vmeta_arith_nv:
  |
  |->vmeta_unm:
  |
  |->vmeta_arith_vvo:
  |->vmeta_arith_vv:
  |
  |  // Call metamethod for binary op.
  |->vmeta_binop:
  |
  |->vmeta_len:
  |
  |//-- Call metamethod ----------------------------------------------------
  |
  |->vmeta_call_ra:
  |->vmeta_call:			// Resolve and call __call metamethod.
  |
  |//-- Argument coercion for 'for' statement ------------------------------
  |
  |->vmeta_for:
  |
  |//-----------------------------------------------------------------------
  |//-- Fast functions -----------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |.macro .ffunc, name
  |->ff_ .. name:
  |.endmacro
  |
  |.macro .ffunc_1, name
  |->ff_ .. name:
  |.endmacro
  |
  |.macro .ffunc_2, name
  |->ff_ .. name:
  |.endmacro
  |
  |.macro .ffunc_n, name, op
  |  .ffunc_1 name
  |.endmacro
  |
  |.macro .ffunc_n, name
  |  .ffunc_n name, mvc
  |.endmacro
  |
  |.macro .ffunc_nn, name
  |  .ffunc_2 name
  |.endmacro
  |
  |// Inlined GC threshold check. Caveat: uses label 1.
  |.macro ffgccheck
  |.endmacro
  |
  |//-- Base library: checks -----------------------------------------------
  |
  |.ffunc_1 assert
  |
  |.ffunc_1 type
  |
  |//-- Base library: getters and setters ---------------------------------
  |
  |.ffunc_1 getmetatable
  |
  |.ffunc_2 setmetatable
  |
  |.ffunc_2 rawget
  |
  |//-- Base library: conversions ------------------------------------------
  |
  |.ffunc tonumber
  |
  |.ffunc_1 tostring
  |
  |//-- Base library: iterators -------------------------------------------
  |
  |.ffunc_1 next
  |
  |.ffunc_1 pairs
  |
  |.ffunc_2 ipairs_aux
  |->fff_res0:
  |
  |.ffunc_1 ipairs
  |
  |//-- Base library: catch errors ----------------------------------------
  |
  |.ffunc_1 pcall
  |
  |.ffunc_2 xpcall
  |
  |//-- Coroutine library --------------------------------------------------
  |
  |.macro coroutine_resume_wrap, resume
  |.if resume
  |.ffunc_1 coroutine_resume
  |.else
  |.ffunc coroutine_wrap_aux
  |.endif
  |.endmacro
  |
  |  coroutine_resume_wrap 1		// coroutine.resume
  |  coroutine_resume_wrap 0		// coroutine.wrap
  |
  |.ffunc coroutine_yield
  |
  |//-- Math library -------------------------------------------------------
  |
  |  .ffunc_1 math_abs
  |->fff_resbit:
  |->fff_resi:
  |->fff_resRB:
  |
  |.ffunc_n math_sqrt, sqrtsd
  |->fff_resxmm0:
  |
  |->fff_res1:
  |->fff_res:
  |->fff_res_:
  |
  |.macro math_round, func
  |  .ffunc math_ .. func
  |.endmacro
  |
  |  math_round floor
  |  math_round ceil
  |
  |.ffunc math_log
  |
  |.macro math_extern, func
  |  .ffunc_n math_ .. func
  |.endmacro
  |
  |.macro math_extern2, func
  |  .ffunc_nn math_ .. func
  |.endmacro
  |
  |  math_extern log10
  |  math_extern exp
  |  math_extern sin
  |  math_extern cos
  |  math_extern tan
  |  math_extern asin
  |  math_extern acos
  |  math_extern atan
  |  math_extern sinh
  |  math_extern cosh
  |  math_extern tanh
  |  math_extern2 pow
  |  math_extern2 atan2
  |  math_extern2 fmod
  |
  |.ffunc_2 math_ldexp
  |
  |.ffunc_n math_frexp
  |
  |.ffunc_n math_modf
  |.macro math_minmax, name, cmovop, sseop
  |  .ffunc name
  |.endmacro
  |
  |  math_minmax math_min, cmovg, minsd
  |  math_minmax math_max, cmovl, maxsd
  |
  |//-- String library -----------------------------------------------------
  |
  |.ffunc string_byte			// Only handle the 1-arg case here.
  |
  |.ffunc string_char			// Only handle the 1-arg case here.
  |->fff_newstr:
  |->fff_resstr:
  |
  |.ffunc string_sub
  |
  |->fff_emptystr:  // Range underflow.
  |
  |.macro ffstring_op, name
  |  .ffunc_1 string_ .. name
  |.endmacro
  |
  |ffstring_op reverse
  |ffstring_op lower
  |ffstring_op upper
  |
  |//-- Bit library --------------------------------------------------------
  |
  |.macro .ffunc_bit, name, kind, fdef
  |  fdef name
  |.endmacro
  |
  |.macro .ffunc_bit, name, kind
  |  .ffunc_bit name, kind, .ffunc_1
  |.endmacro
  |
  |.ffunc_bit bit_tobit, 0
  |
  |.macro .ffunc_bit_op, name, ins
  |  .ffunc_bit name, 2
  |.endmacro
  |
  |.ffunc_bit_op bit_band, and
  |.ffunc_bit_op bit_bor, or
  |.ffunc_bit_op bit_bxor, xor
  |
  |.ffunc_bit bit_bswap, 1
  |
  |.ffunc_bit bit_bnot, 1
  |->fff_resbit:
  |
  |->fff_fallback_bit_op:
  |
  |.macro .ffunc_bit_sh, name, ins
  |  .ffunc_bit name, 1, .ffunc_2
  |.endmacro
  |
  |.ffunc_bit_sh bit_lshift, shl
  |.ffunc_bit_sh bit_rshift, shr
  |.ffunc_bit_sh bit_arshift, sar
  |.ffunc_bit_sh bit_rol, rol
  |.ffunc_bit_sh bit_ror, ror
  |
  |//-----------------------------------------------------------------------
  |
  |->fff_fallback_2:
  |->fff_fallback_1:
  |->fff_fallback:			// Call fast function fallback handler.
  |
  |// Reconstruct previous base for vmeta_call during tailcall.
  |->vm_call_tail:
  |
  |->fff_gcstep:			// Call GC step function.
  |  // BASE = new base, RD = nargs+1
  |
  |//-----------------------------------------------------------------------
  |//-- Special dispatch targets -------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_record:				// Dispatch target for recording phase.
  |
  |->vm_rethook:			// Dispatch target for return hooks.
  |
  |->vm_inshook:			// Dispatch target for instr/line hooks.
  |
  |->cont_hook:				// Continue from hook yield.
  |
  |->vm_hotloop:			// Hot loop counter underflow.
  |
  |->vm_callhook:			// Dispatch target for call hooks.
  |
  |->vm_hotcall:			// Hot call counter underflow.
  |
  |->cont_stitch:			// Trace stitching.
  |
  |->vm_profhook:			// Dispatch target for profiler hook.
  |
  |//-----------------------------------------------------------------------
  |//-- Trace exit handler -------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |// Called from an exit stub with the exit number on the stack.
  |// The 16 bit exit number is stored with two (sign-extended) push imm8.
  |->vm_exit_handler:
  |->vm_exit_interp:
  |
  |//-----------------------------------------------------------------------
  |//-- Math helper functions ----------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |.macro vm_round, name, mode, cond
  |->name:
  |.endmacro
  |
  |  vm_round vm_floor, 0, 1
  |  vm_round vm_ceil,  1, JIT
  |  vm_round vm_trunc, 2, JIT
  |
  |// FP modulo x%y. Called by BC_MOD* and vm_arith.
  |->vm_mod:
  |
  |// Args in xmm0/eax. Ret in xmm0. xmm0-xmm1 and eax modified.
  |->vm_powi_sse:
  |
  |//-----------------------------------------------------------------------
  |//-- Miscellaneous functions --------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |// int lj_vm_cpuid(uint32_t f, uint32_t res[4])
  |->vm_cpuid:
  |
  |//-----------------------------------------------------------------------
  |//-- Assertions ---------------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->assert_bad_for_arg_type:
#ifdef LUA_USE_ASSERT
#endif
  |
  |//-----------------------------------------------------------------------
  |//-- FFI helper functions -----------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |// Handler for callback functions. Callback slot number in ah/al.
  |->vm_ffi_callback:
  |
  |->cont_ffi_callback:			// Return from FFI callback.
  |
  |->vm_ffi_call:			// Call C function via FFI.
  |// Note: vm_ffi_call must be the last function in this object file!
  |
  |//-----------------------------------------------------------------------
}

/* Generate the code for a single instruction. */
static void build_ins(BuildCtx *ctx, BCOp op, int defop)
{
  int vk = 0;
  (void)vk;
  |// Note: aligning all instructions does not pay off.
  |=>defop:

  switch (op) {
  case BC_ISLT: case BC_ISGE: case BC_ISLE: case BC_ISGT:
  case BC_ISEQV: case BC_ISNEV:
  case BC_ISEQS: case BC_ISNES:
  case BC_ISEQN: case BC_ISNEN:
  case BC_ISEQP: case BC_ISNEP:
  case BC_ISTC: case BC_ISFC: case BC_IST: case BC_ISF:
  case BC_ISTYPE:
  case BC_ISNUM:
  case BC_MOV:
  case BC_NOT:
  case BC_UNM:
  case BC_LEN:
  case BC_ADDVN: case BC_ADDNV: case BC_ADDVV:
  case BC_SUBVN: case BC_SUBNV: case BC_SUBVV:
  case BC_MULVN: case BC_MULNV: case BC_MULVV:
  case BC_DIVVN: case BC_DIVNV: case BC_DIVVV:
  case BC_MODVN:
  case BC_MODNV: case BC_MODVV:
  case BC_POW:
  case BC_CAT:
  case BC_KSTR:
  case BC_KCDATA:
  case BC_KSHORT:
  case BC_KNUM:
  case BC_KPRI:
  case BC_KNIL:
  case BC_UGET:
  case BC_USETV:
  case BC_USETS:
  case BC_USETN:
  case BC_USETP:
  case BC_UCLO:
  case BC_FNEW:
  case BC_TNEW:
  case BC_TDUP:
  case BC_GGET:
  case BC_GSET:
  case BC_TGETV:
  case BC_TGETS:
  case BC_TGETB:
  case BC_TGETR:
  case BC_TSETV:
  case BC_TSETS:
  case BC_TSETB:
  case BC_TSETR:
  case BC_TSETM:
  case BC_CALL: case BC_CALLM:
  case BC_CALLMT:
  case BC_CALLT:
  case BC_ITERC:
  case BC_ITERN:
  case BC_ISNEXT:
  case BC_VARG:
  case BC_RETM:
  case BC_RET: case BC_RET0: case BC_RET1:
  case BC_FORL:
  case BC_JFORI:
  case BC_JFORL:
  case BC_FORI:
  case BC_IFORL:
  case BC_ITERL:
  case BC_JITERL:
  case BC_IITERL:
  case BC_LOOP:
  case BC_ILOOP:
  case BC_JLOOP:
  case BC_JMP:
  case BC_FUNCF:
  case BC_FUNCV:  /* NYI: compiled vararg functions. */
  case BC_JFUNCF:
  case BC_IFUNCF:
  case BC_JFUNCV:
  case BC_IFUNCV:
  case BC_FUNCC:
  case BC_FUNCCW:
    | lg r0, 0(r0) // Not implemented, seg fault.
    break;

  /* ---------------------------------------------------------------------- */

  default:
    fprintf(stderr, "Error: undefined opcode BC_%s\n", bc_names[op]);
    exit(2);
    break;
  }
}

static int build_backend(BuildCtx *ctx)
{
  int op;
  dasm_growpc(Dst, BC__MAX);
  build_subroutines(ctx);
  |.code_op
  for (op = 0; op < BC__MAX; op++)
    build_ins(ctx, (BCOp)op, op);
  return BC__MAX;
}

/* Emit pseudo frame-info for all assembler functions. */
static void emit_asm_debug(BuildCtx *ctx)
{
}
