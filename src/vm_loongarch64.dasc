|// Low-level VM code for LoongArch CPUs.
|// Bytecode interpreter, fast functions and helper functions.
|// Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
|
|.arch loongarch64
|
|//-----------------------------------------------------------------------
|
|// Fixed register assignments for the interpreter.
|// Don't use: r0 = 0, r1 = ra, r2 = tp, r3 = sp, r21 = reserved
|
|
|// The following must be C callee-save (but BASE is often refetched).
|.define BASE,		r23	// Base of current Lua stack frame.
|.define KBASE,		r24	// Constants of current Lua function.
|.define PC,		r25	// Next PC.
|.define DISPATCH,	r26	// Opcode dispatch table.
|.define LREG,		r27	// Register holding lua_State (also in SAVE_L).
|.define MULTRES,	r28	// Size of multi-result: (nresults+1)*8.
|
|.define JGL,		r22	// On-trace: global_State + 32768.
|
|// Constants for type-comparisons, stores and conversions. C callee-save.
|.define TISNIL,	r22
|.define TISNUM,	r29
|.define TOBIT,		f30	// 2^52 + 2^51.
|
|// The following temporaries are not saved across C calls, except for RA.
|.define RA,		r30	// Callee-save.
|.define RB,		r8
|.define RC,		r9
|.define RD,		r10
|.define INS,		r11
|
|.define TMP0,		r12
|.define TMP1,		r13
|.define TMP2,		r14
|.define TMP3,		r15
|.define TMP4,		r17
|
|// Loongarch lp64 calling convention.
|.define CARG1,		r4
|.define CARG2,		r5
|.define CARG3,		r6
|.define CARG4,		r7
|.define CARG5,		r8
|.define CARG6,		r9
|.define CARG7,		r10
|.define CARG8,		r11
|
|.define CRET1,		r4
|.define CRET2,		r5
|
|.define FARG1,		f0
|.define FARG2,		f1
|.define FARG3,		f2
|.define FARG4,		f3
|.define FARG5,		f4
|.define FARG6,		f5
|.define FARG7,		f6
|.define FARG8,		f7
|
|.define FRET1,		f0
|.define FRET2,		f1
|
|.define FTMP0,		f8
|.define FTMP1,		f9
|.define FTMP2,		f10
|.define FTMP3,		f22
|.define FTMP4,		f23
|
|.define FCC0,		fcc0
|.define FCC1,		fcc1
|
|// Stack layout while in interpreter. Must match with lj_frame.h.
|// LoongArch64 hard-float.
|
|.define CFRAME_SPACE,	200	// Delta for sp.
|
|//----- 16 byte aligned, <-- sp entering interpreter
|.define SAVE_ERRF,	196	// 32 bit values.
|.define SAVE_NRES,	192
|.define SAVE_CFRAME,	184	// 64 bit values.
|.define SAVE_L,	176
|.define SAVE_PC,	168
|//----- 16 byte aligned
|.define SAVE_GPR_,	80	// .. 80+11*8: 64 bit GPR saves.
|.define SAVE_FPR_,	16	// .. 16+8*8: 64 bit FPR saves.
|
|
|.define TMPD,		0
|//----- 16 byte aligned
|
|.define TMPD_OFS,	0
|
|//-----------------------------------------------------------------------
|
|.macro saveregs
|  addi.d sp, sp, -CFRAME_SPACE
|  st.d ra, SAVE_GPR_+10*8(sp)
|  st.d r22, SAVE_GPR_+9*8(sp)
|  st.d r31, SAVE_GPR_+8*8(sp)
|  fst.d f31, SAVE_FPR_+7*8(sp)
|  st.d r30, SAVE_GPR_+7*8(sp)
|  fst.d f30, SAVE_FPR_+6*8(sp)
|  st.d r29, SAVE_GPR_+6*8(sp)
|  fst.d f29, SAVE_FPR_+5*8(sp)
|  st.d r28, SAVE_GPR_+5*8(sp)
|  fst.d f28, SAVE_FPR_+4*8(sp)
|  st.d r27, SAVE_GPR_+4*8(sp)
|  fst.d f27, SAVE_FPR_+3*8(sp)
|  st.d r26, SAVE_GPR_+3*8(sp)
|  fst.d f26, SAVE_FPR_+2*8(sp)
|  st.d r25, SAVE_GPR_+2*8(sp)
|  fst.d f25, SAVE_FPR_+1*8(sp)
|  st.d r24, SAVE_GPR_+1*8(sp)
|  fst.d f24, SAVE_FPR_+0*8(sp)
|  st.d r23, SAVE_GPR_+0*8(sp)
|.endmacro
|
|.macro restoreregs_ret
|  ld.d ra, SAVE_GPR_+10*8(sp)
|  ld.d r22, SAVE_GPR_+9*8(sp)
|  ld.d r31, SAVE_GPR_+8*8(sp)
|  ld.d r30, SAVE_GPR_+7*8(sp)
|  fld.d f31, SAVE_FPR_+7*8(sp)
|  ld.d r29, SAVE_GPR_+6*8(sp)
|  fld.d f30, SAVE_FPR_+6*8(sp)
|  ld.d r28, SAVE_GPR_+5*8(sp)
|  fld.d f29, SAVE_FPR_+5*8(sp)
|  ld.d r27, SAVE_GPR_+4*8(sp)
|  fld.d f28, SAVE_FPR_+4*8(sp)
|  ld.d r26, SAVE_GPR_+3*8(sp)
|  fld.d f27, SAVE_FPR_+3*8(sp)
|  ld.d r25, SAVE_GPR_+2*8(sp)
|  fld.d f26, SAVE_FPR_+2*8(sp)
|  ld.d r24, SAVE_GPR_+1*8(sp)
|  fld.d f25, SAVE_FPR_+1*8(sp)
|  ld.d r23, SAVE_GPR_+0*8(sp)
|  fld.d f24, SAVE_FPR_+0*8(sp)
|  addi.d sp, sp, CFRAME_SPACE
|  jirl r0, ra, 0
|.endmacro
|
|//-----------------------------------------------------------------------
|
|.macro .STXW, a, b, c
|  addu16i.d r20, r0, c
|  srai.d r20, r20, 16
|  stx.w a, b, r20
|.endmacro
|
|.macro .STXD, a, b, c
|  addu16i.d r20, r0, c
|  srai.d r20, r20, 16
|  stx.d a, b, r20
|.endmacro
|
|.macro .LDXW, a, b, c
|  addu16i.d r20, r0, c
|  srai.d r20, r20, 16
|  ldx.w a, b, r20
|.endmacro
|
|.macro .LDXD, a, b, c
|  addu16i.d r20, r0, c
|  srai.d r20, r20, 16
|  ldx.d a, b, r20
|.endmacro
|
|.macro .LDXBU, a, b, c
|  addu16i.d r20, r0, c
|  srai.d r20, r20, 16
|  ldx.bu a, b, r20
|.endmacro
|
|.macro .ADD16I, a, b, c
|  addu16i.d r20, r0, c
|  srai.d r20, r20, 16
|  add.d a, b, r20
|.endmacro
|
|// Type definitions. Some of these are only used for documentation.
|.type L,		lua_State,	LREG
|.type GL,		global_State
|.type TVALUE,		TValue
|.type GCOBJ,		GCobj
|.type STR,		GCstr
|.type TAB,		GCtab
|.type LFUNC,		GCfuncL
|.type CFUNC,		GCfuncC
|.type PROTO,		GCproto
|.type UPVAL,		GCupval
|.type NODE,		Node
|.type NARGS8,		int
|.type TRACE,		GCtrace
|.type SBUF,		SBuf
|
|//-----------------------------------------------------------------------
|
|// Trap for not-yet-implemented parts.
|.macro NYI; break 0; .endmacro
|
|//-----------------------------------------------------------------------
|
|// Access to frame relative to BASE.
|.define FRAME_PC,	-8
|.define FRAME_FUNC,	-16
|
|//-----------------------------------------------------------------------
|
|// Endian-specific defines. LoongArch is little endian.
|.define OFS_RD,	2
|.define OFS_RA,	1
|.define OFS_OP,	0
|
|// Instruction decode.
|.macro decode_BC4b, dst; slli.w dst, dst, 2; .endmacro
|.macro decode_BC8b, dst; slli.w dst, dst, 3; .endmacro
|.macro decode_OP, dst, ins; andi dst, ins, 0xff; .endmacro
|.macro decode_RA, dst, ins; bstrpick.d dst, ins, 15, 8; decode_BC8b dst; .endmacro
|.macro decode_RB, dst, ins; bstrpick.d dst, ins, 31, 24; decode_BC8b dst; .endmacro
|.macro decode_RC, dst, ins; bstrpick.d dst, ins, 23, 16; decode_BC8b dst; .endmacro
|.macro decode_RD, dst, ins; bstrpick.d dst, ins, 31, 16; decode_BC8b dst; .endmacro
|.macro decode_RDtoRC8, dst, src; andi dst, src, 0x7f8; .endmacro
|
|// Instruction fetch.
|.macro ins_NEXT1
|  ld.w INS, 0(PC)
|  addi.d PC, PC, 4
|.endmacro
|// Instruction decode+dispatch.
|.macro ins_NEXT2
|  decode_OP TMP1, INS
|  decode_BC8b TMP1
|  add.d TMP0, DISPATCH, TMP1
|  ld.d TMP4, 0(TMP0)
|   decode_RD RD, INS
|   decode_RA RA, INS
|  jirl r0, TMP4, 0
|.endmacro
|.macro ins_NEXT
|  ins_NEXT1
|  ins_NEXT2
|.endmacro
|
|// Instruction footer.
|.if 1
|  // Replicated dispatch. Less unpredictable branches, but higher I-Cache use.
|  .define ins_next, ins_NEXT
|  .define ins_next_, ins_NEXT
|  .define ins_next1, ins_NEXT1
|  .define ins_next2, ins_NEXT2
|.else
|  // Common dispatch. Lower I-Cache use, only one (very) unpredictable branch.
|  // Affects only certain kinds of benchmarks (and only with -j off).
|  .macro ins_next
|    b ->ins_next
|  .endmacro
|  .macro ins_next1
|  .endmacro
|  .macro ins_next2
|    b ->ins_next
|  .endmacro
|  .macro ins_next_
|  ->ins_next:
|    ins_NEXT
|  .endmacro
|.endif
|
|// Call decode and dispatch.
|.macro ins_callt
|  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
|  ld.d PC, LFUNC:RB->pc
|  ld.w INS, 0(PC)
|  addi.d PC, PC, 4
|  decode_OP TMP1, INS
|  decode_RA RA, INS
|  decode_BC8b TMP1
|  add.d TMP0, DISPATCH, TMP1
|  ld.d TMP0, 0(TMP0)
|  add.d RA, RA, BASE
|  jirl r0, TMP0, 0
|.endmacro
|
|.macro ins_call
|  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, PC = caller PC
|  st.d PC, FRAME_PC(BASE)
|  ins_callt
|.endmacro
|
|//-----------------------------------------------------------------------
|
|.macro branch_RD
|  srli.w TMP0, RD, 1
|  addu16i.d TMP4, r0, -0x2	// -BCBIAS_J*4
|  add.w TMP0, TMP0, TMP4	// (jump - 0x8000)<<2
|  add.d PC, PC, TMP0
|.endmacro
|
|// Assumes DISPATCH is relative to GL.
#define DISPATCH_GL(field)	(GG_DISP2G + (int)offsetof(global_State, field))
#define DISPATCH_J(field)	(GG_DISP2J + (int)offsetof(jit_State, field))
|
#define PC2PROTO(field)  ((int)offsetof(GCproto, field)-(int)sizeof(GCproto))
|
|
|// Set current VM state. Uses TMP0.
|.macro li_vmstate, st; addi.w TMP0, r0, ~LJ_VMST_..st; .endmacro
|.macro st_vmstate; .STXW TMP0, DISPATCH, DISPATCH_GL(vmstate); .endmacro
|
|// Move table write barrier back. Overwrites mark and tmp.
|.macro barrierback, tab, mark, tmp, target
|  .LDXD tmp, DISPATCH, DISPATCH_GL(gc.grayagain)
|  andi mark, mark, ~LJ_GC_BLACK & 255		// black2gray(tab)
|  .STXD tab, DISPATCH, DISPATCH_GL(gc.grayagain)
|  st.b mark, tab->marked
|  st.d tmp, tab->gclist
|  b target
|.endmacro
|
|// Clear type tag. Isolate lowest 47 bits of reg.
|.macro cleartp, reg; bstrpick.d reg, reg, 46, 0; .endmacro
|.macro cleartp, dst, reg; bstrpick.d dst, reg, 46, 0; .endmacro
|
|// Set type tag: Merge 17 type bits into bits [47, 63] of dst.
|.macro settp, dst, tp; bstrins.d dst, tp, 63, 47; .endmacro
|
|// Extract (negative) type tag.
|.macro gettp, dst, src; srai.d dst, src, 47; .endmacro
|
|// Macros to check the TValue type and extract the GCobj. Branch on failure.
|.macro checktp, reg, tp, target
|  gettp TMP4, reg
|  addi.d TMP4, TMP4, tp
|  cleartp reg
|  bnez TMP4, target
|.endmacro
|.macro checktp, dst, reg, tp, target
|  gettp TMP4, reg
|  addi.d TMP4, TMP4, tp
|  cleartp dst, reg
|  bnez TMP4, target
|.endmacro
|.macro checkstr, reg, target; checktp reg, -LJ_TSTR, target; .endmacro
|.macro checktab, reg, target; checktp reg, -LJ_TTAB, target; .endmacro
|.macro checkfunc, reg, target; checktp reg, -LJ_TFUNC, target; .endmacro
|.macro checkint, reg, target
|  gettp TMP4, reg
|  bne TMP4, TISNUM, target
|.endmacro
|.macro checknum, reg, target
|  gettp TMP4, reg
|  sltui TMP4, TMP4, LJ_TISNUM
|  beqz TMP4, target
|.endmacro
|
|.macro mov_false, reg
|  addi.d reg, r0, 0x0001
|  slli.d reg, reg, 47
|  nor reg, reg, r0
|.endmacro
|.macro mov_true, reg
|  addi.d reg, r0, 0x0001
|  slli.d reg, reg, 48
|  nor reg, reg, r0
|.endmacro
|
|//-----------------------------------------------------------------------
